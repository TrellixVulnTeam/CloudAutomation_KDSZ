"""
Status Module
==========
"""

import os
import time
import logging
import lxk_sentry
from lxk_testlib import rob
from lxk_testlib.snmp import snmp
from lxk_testlib.utils import ssh
from lxk_printer_device.webservices import automation
from lxk_printer_device.workflows import device, network

LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.DEBUG)
 

def wake_up_printer_device(ip_address):
    """
    Wake up the printer from power saving mode.

    :Parameters:

        1. ip_address, ``<class 'str'>``

    :Returns: ``None``
    """
    LOGGER.debug(ip_address)
    cmd = '''call powermanager request_state_change "{ii}" deviceId 13 stateId 1'''
    LOGGER.debug(cmd)
    returnoutput = rob.execute(ip_address, cmd)
    LOGGER.debug(returnoutput)
    if 'result' not in returnoutput[1]:
        assert False, (
            'Please deploy "Debug Enablement License Bundle" to your printer ',
            'through the licensing server. ',
            'https://cdp.lexmark.com/licensing-server/'
        )

def check_printer_status(ip_address, status):
    """
    Compare printer device status.

    :Parameters:

        1. ip_address, ``<class 'str'>``
        2. status, ``<class 'str'>``

    :Returns: Result ``<class 'bool'>``
    """
    LOGGER.debug(ip_address)
    LOGGER.debug(status)
    cmd = '''call statusapi.Printer getSession "{s}" type "Status"'''
    LOGGER.debug(cmd)
    ret = rob.execute(ip_address, cmd)
    LOGGER.debug(ret)
    return bool(status in ret[1])

def wait_for_reboot_and_be_ready(ip_address):
    """
    Wait for the printer to reboot and ready.

    :Parameters:

        1. ip_address, ``<class 'str'>``

    :Returns: Ready ``<class 'bool'>``
    """
    LOGGER.debug(ip_address)
    network.wait_for_no_ping(ip_address)
    network.wait_for_ping(ip_address)
    ready = wait_for_ready(ip_address)
    return ready

def wait_for_ready(ip_address, check_automation_enabled=True):
    """
    Wait for the printer to be ready with in 8 minutes.

    :Parameters:

        1. ip_address, ``<class 'str'>``

    :Returns: Ready ``<class 'bool'>``
    """
    LOGGER.debug(ip_address)
    ready = False
    for _ in range(0, 250):
        # check rob statusapi
        cmd = '''call statusapi.Printer getSession "{s}" type "Status"'''
        LOGGER.debug(cmd)
        return_output = rob.execute(ip_address, cmd)
        LOGGER.debug(return_output)
        statusapi_ready = "TEXT : : Busy" not in return_output[1]

        if check_automation_enabled:
            # check webservices automation
            automation_ready = automation.is_enabled(ip_address)
            msg = "Device and Webservices Automation"
        else:
            automation_ready = True
            msg = "Device"

        if statusapi_ready and automation_ready:
            LOGGER.info("{} is now ready!".format(msg))
            ready = True
            break
        else:
            LOGGER.info("{} are not ready...".format(msg))
            time.sleep(2)
    else:
        assert False, '{msg} are not ready ({ip})'.format(msg=msg, ip=ip_address)
    LOGGER.debug(ready)
    return ready
 
def wait_for_first_boot_object(ip_address):
    """
    Wait for 8 minutes for printer's first boot menu to appear on the printer.

    :Parameters:

        1. ip_address, ``<class 'str'>``

    :Returns: ``True`` or ``<class 'AssertionError'>``
    """
    LOGGER.debug(ip_address)
    for _ in range(0, 30):
        cmd = '''call rob listObjects 'n'|grep applications.firstBootMenu'''
        LOGGER.debug(cmd)
        returnoutput = rob.execute(ip_address, cmd)
        LOGGER.debug(returnoutput)
        cnt = len(returnoutput[1])
        if cnt > 0:
            break
        time.sleep(10)
    else:
        assert False, 'applications.firstBootMenu not found on ROB bus'
    return True
 
def exit_first_boot_wizard(ip_address):
    """    
    Exit first boot wizard.

    :Parameters:

        1. ip_address, ``<class 'str'>``

    :Returns: Success ``<class 'bool'>``
    """
    LOGGER.debug(ip_address)
    # only supported in Linux
    assert_linux()

    cmd = '''call applications.firstBootMenu exitFirstBootMenu "n"'''
    returnoutput = rob.execute(ip_address, cmd)
    LOGGER.debug(returnoutput)
    return bool("result : :i 0" in returnoutput[1])

def restore_factory_default(ip_address, value, reboot):
    """
    Restore printer to factory defaults and reboot afterwards. If run in sentry
    page suppression is turned 'On'.

    :Parameters:

        1. value, ``<class 'str'>``, please check rob document for possible values.
        http://documentation.lpdev.prtdev.lexmark.com/robdocs/

    :Returns: ``None``
    """
    LOGGER.debug(ip_address)
    LOGGER.debug(value)

    cmd = '''call system.settings restoreFactoryDefault "{(s)}" types "''' + value + '''"'''
    LOGGER.debug(cmd)
    return_output = rob.execute(ip_address, cmd)
    LOGGER.debug(return_output)
    if "success : :null" in return_output[1] or "success : :b true" in return_output[1]:
        LOGGER.info("Restored to factory default %s", value)

        if reboot:
            reboot_device(ip_address)

        wait_for_ready(ip_address)
        LOGGER.info("Printer should be ready by now!")
        if lxk_sentry.LxkSentry().is_run_in_sentry():
            device.set_page_suppression(ip_address, "on")
    else:
        assert False, 'ERROR: Restoring to factory default, {}'.format(value)

def crash_to_firmware_error(ip_address):
    """
    Purposely crash printer device to firmware error.

    :Parameters:

        1. ip_address, ``<class 'str'>``

    :Returns: ``None``
    """
    LOGGER.debug(ip_address)

    cmd = "svcerr-test -n"
    ssh.execute(ip_address, cmd)

def clear_sim_engine_irs(ip_address):
    """
    Clear IR from the panel. This will mostly work on sim.

    :Parameters:

        1. ip_address, ``<class 'str'>``

    :Returns: ``None``
    """
    LOGGER.debug(ip_address)

    # only supported in Linux
    assert_linux()

    cmd = '''call statusapi.Printer getSession "{s}" type "Intervention"'''
    returnoutput = rob.execute(ip_address, cmd)
    LOGGER.debug(returnoutput)
    ir_id = str(misc.get_result(returnoutput[1], " ID : :i"))
    action_id = str(misc.get_result(returnoutput[1], "ACTIONS : :i"))
    clear_cmd = '''call statusapi.Printer performAction "{ii}" ACTIONS ''' + action_id +''' ID ''' + ir_id
    LOGGER.debug(clear_cmd)
    returnoutput = rob.execute(ip_address, cmd)
    LOGGER.debug(returnoutput)

def wait_for_ir(ip_address, community = "public", port = 161, timeout = 1.0, retries = 5):
    """
    Wait until the device is busy but not offline
    """
    not_busy = True
    i = 0

    _snmp = snmp.SNMPLibrary()
    _snmp.open_snmp_v2c_connection(ip_address, community, port, timeout, retries)

    while not_busy and i < 120:
        
        output = _snmp.walk(".1.3.6.1.2.1.25.3.5.1.1")

        if "other" in output or ": 1" in output or "1" in output[0][1]: 
            print("IR found on printer")
            not_busy = False
        else:
            print("Printer status: {0}".format(output))
            i += 1
            time.sleep(1)
    if not_busy:
        assert False, "ErrMsg: IR should have appeared within 2 minutes"

def reboot_device(ip_address):
    """
    Reboot printer device through ssh
    Wait for 30seconds and check if device is already pingable
    """
    command = "reboot -f &>/dev/null & exit"
    ssh.execute(ip_address, command)
    time.sleep(30)
    network.wait_for_ping(ip_address)
        
    
    




