"""
SIM UTILS
---------
"""

import os
import re
import json
import time
import logging
import datetime
import xml.etree.ElementTree as ET
import xml.dom.minidom as minidom
from lxk_testlib import rob
from lxk_testlib.utils import ssh
from lxk_printer_device.workflows import device

LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.DEBUG)

def restore_original_configuration(ipaddress):
    """
    Main function that empties the contents of the patches directory to restore original sim tray and devices configuration

    Args:
        ipaddress - ip address of SIM
    Return:
        True if successfully cleared; False otherwise
    """
    success = True
    msg = "All good"

    command = '''rm -fr /var/fs/patches/*; sync'''
    print (command)
    LOGGER.debug(command)
    response = ssh.execute(ipaddress, command)
    print (response)
    print ("\n")
    LOGGER.debug(response)
    device.reboot(ipaddress)

    return (success, msg)

def install_remove_devices(ipaddress, perform_action, device_option, option1, option2):
    """
    Main function that modifies content of xml files

    Args:
        ipaddress - ip address of SIM
        perform_action - action to be done (install,remove,replace)
        device_option - Type of device (tray or output device like bin or finisher)
        option1 - Name of device
        option2 - Device specifics

    Return:
        True if successfully modified the sim cofiguration; False otherwise
    """
    success = True
    msg = "All good"

    print (perform_action)
    print (device_option)
    print (option1)
    print (option2)
    print ("---------")
    print ("\n")

    LOGGER.debug(perform_action)
    LOGGER.debug(device_option)
    LOGGER.debug(option1)
    LOGGER.debug(option2)

    ### initialization
    xml_type = get_xml_type(device_option)
    npa_id = get_npa_id(option1)
    npa_id2 = get_npa_id(option2)
    print (xml_type)
    print (npa_id)
    print (npa_id2)
    print ("---------")
    print ("\n")
    LOGGER.debug(xml_type)
    LOGGER.debug(npa_id)
    LOGGER.debug(npa_id2)

    if npa_id == None:
        success = False
        msg = "ErrMsg: Invalid device name (1st parameter)"
    else:
        if device_option == "tray":
            if perform_action == "install" or perform_action == "replace":
                if npa_id2 == None:
                    success = False
                    msg = "ErrMsg: Invalid device name (2nd parameter)"
        if perform_action == "replace" and device_option == "device":
            if npa_id2 == None:
                success = False
                msg = "ErrMsg: Invalid device name (2nd parameter)"

        if success:
            ### process xml file
            process_xml_file(xml_type, perform_action, npa_id, npa_id2)

    return (success, msg)

def initialize_configuration(ipaddress, fw_version):
    """
    Main function that downloads the necessary XML files from the SIM

    Args:
        ipaddress - ip address of SIM
        fw_version - FW version. needed this to know the persona directory

    Return:
        True if successfully downloaded the XML files; False otherwise
    """
    success = True
    msg = "All good"

    print (fw_version)
    print ("---------")
    print ("\n")
    LOGGER.debug(fw_version)

    ### initialization
    persona = get_persona(fw_version)
    xml_type = get_xml_type("Tray")
    xml_type2 = get_xml_type("Device")
    print (persona)
    print (xml_type)
    print (xml_type2)
    print ("---------")
    print ("\n")
    LOGGER.debug(persona)
    LOGGER.debug(xml_type)
    LOGGER.debug(xml_type2)

    ### copy xml file from SIM
    copy_xml_from_sim(ipaddress, persona, xml_type)
    copy_xml_from_sim(ipaddress, persona, xml_type2)

    return (success, msg)

def finalize_configuration(ipaddress):
    """
    Main function that sends back the necessary XML files to the SIM

    Args:
        ipaddress - ip address of SIM

    Return:
        True if successfully sent the XML files; False otherwise
    """
    success = True
    msg = "All good"

    xml_type = get_xml_type("Tray")
    xml_type2 = get_xml_type("Device")

    ### create override path
    create_varfs_extension(ipaddress)

    ### copy xml file to SIM
    copy_xml_to_sim(ipaddress, xml_type)
    copy_xml_to_sim(ipaddress, xml_type2)

    ### sync and reboot
    sync_and_reboot(ipaddress)

    return (success, msg)

def copy_xml_from_sim(ipaddress, persona, xml_type):
    """
    Helper function. copies xml file from SIM

    Args:
        ipaddress - SIM ip address
		persona - printer's persona
        xml_type - original XML file of the SIM
    """
    command = '''scp root@{}:/usr/share/printservice/xml/{}/{} .'''.format(ipaddress, persona, xml_type)
    print (command)
    LOGGER.debug(command)
    resp = os.popen(command).read()
    print (resp)
    print ("\n")
    LOGGER.debug(resp)

def copy_xml_to_sim(ipaddress, xml_type):
    """
    Helper function. copies xml file to SIM

    Args:
        ipaddress - SIM ip address
        xml_type - specific xml that has the changes
    """
    command2 = '''scp {} root@{}:/var/fs/patches/usr/share/printservice/xml/{}'''.format(xml_type, ipaddress, xml_type)
    print (command2)
    LOGGER.debug(command2)
    resp2 = os.popen(command2).read()
    print (resp2)
    print ("\n")
    LOGGER.debug(resp2)

def process_xml_file(xml_type, perform_action, npa_id, npa_id2):
    """
    Helper function. process the xml file to add,remove,modify elements

    Args:
        xml_type - specific xml to modify
        perform_action - install, remove, replace
        npa_id - npa id of device
        npa_id2 - npa id of device details
    """
    if xml_type == "trays.xml":
        if perform_action == "Remove":
            tree = ET.parse(xml_type)
            root = tree.getroot()
            elem = root.find("trayConfig")
            if elem:
                for subelem in elem:
                    if subelem.get("npaId") == npa_id:
                        elem.remove(subelem)
                        tree.write(xml_type)
                        break
        if perform_action == "Replace":
            tree = ET.parse(xml_type)
            root = tree.getroot()
            elem = root.find("trayConfig")
            if elem:
                for subelem in elem:
                    if subelem.get("npaId") == npa_id:
                        subelem.attrib['trayType'] = npa_id2
                        tree.write(xml_type)
                        break
        if perform_action == "Install":
            tree = ET.parse(xml_type)
            root = tree.getroot()
            elem = root.find("trayConfig")
            el = ET.SubElement(elem, "trayInstance", {'npaId':npa_id,'trayType':npa_id2} )
            ET.SubElement(el, "count", {'value':'550'})
            ET.SubElement(el, "size", {'value':'NPAPAPER_LETTER'})
            ET.SubElement(el, "type", {'value':'NPAPAPER_TYP_PLAIN_PAPER'})
            tree.write(xml_type)
        prettify_xml(xml_type)
    if xml_type == "output_device.xml":
        if perform_action == "Remove":
            tree = ET.parse(xml_type)
            root = tree.getroot()
            elem = root.find("outputDeviceConfig")
            if elem:
                for subelem in elem:
                    if subelem.get("outputType") == npa_id:
                        elem.remove(subelem)
                        tree.write(xml_type)
                        break
        if perform_action == "Replace":
            tree = ET.parse(xml_type)
            root = tree.getroot()
            elem = root.find("outputDeviceConfig")
            if elem:
                for subelem in elem:
                    if subelem.get("outputType") == npa_id:
                        subelem.attrib['outputType'] = npa_id2
                        tree.write(xml_type)
                        break
        if perform_action == "Install":
            tree = ET.parse(xml_type)
            root = tree.getroot()
            elem = root.find("outputDeviceConfig")
            if npa_id == "OUTPUT_DEVICE_TYPE_STACKER":
                isStandardBin = False
                if elem:
                    for subelem in elem:
                        if subelem.get("outputType") == "OUTPUT_DEVICE_TYPE_STANDARD":
                            isStandardBin = True
                            break
                        if subelem.get("outputType") == "OUTPUT_DEVICE_TYPE_STANDARD_WITH_FINISHER":
                            isStandardBin = True
                            break
                if isStandardBin:
                    el = ET.SubElement(elem, "outputDeviceInstance", {'npaId':'NPAOUTPUT_OPTIONAL_BIN3','trayType':npa_id} )
                    ET.SubElement(el, "count", {'value':'0'})
            else:
                el = ET.SubElement(elem, "outputDeviceInstance", {'npaId':'NPAOUTPUT_OPTIONAL_BIN3','trayType':npa_id} )
                ET.SubElement(el, "count", {'value':'0'})
            tree.write(xml_type)
        prettify_xml(xml_type)

def prettify_xml(xml_type):
    """
    Helper function. Fixes the format of the xml to be readable again

    Args:
        xml_type - xml file
    """
    tree = ET.parse(xml_type)
    root = tree.getroot()
    xmlstr = minidom.parseString(ET.tostring(root)).toprettyxml(indent="   ")
    xmlstr = os.linesep.join([s for s in xmlstr.splitlines() if s.strip()])
    with open(xml_type, "w") as file_out:
        file_out.write(xmlstr)

def sync_and_reboot(ipaddress):
    """
    Helper fuction. issues sync command to printer and reboots

    Args:
        ipaddress - printer ip address
    """
    command = '''sync'''
    print (command)
    LOGGER.debug(command)
    response = ssh.execute(ipaddress, command)
    print (response)
    print ("\n")
    LOGGER.debug(response)
    device.reboot(ipaddress)

def create_varfs_extension(ipaddress):
    """
    Helper fuction. creates the directory where the modified xml file will be placed

    Args:
        ipaddress - printer ip address
    """
    command = '''mkdir -p /var/fs/patches/usr/share/printservice/xml/'''
    print (command)
    LOGGER.debug(command)
    response = ssh.execute(ipaddress, command)
    print (response)
    print ("\n")
    LOGGER.debug(response)
    

def get_persona(fw_version):
    """
    Helper function. get the sim persona directory

    Args:
        fw_version - printer FW version or RIP code
    Return:
        printer persona
    """
    persona = ""
    if "PP" in fw_version:
        persona = "palazzo"
    elif "AT" in fw_version:
        persona = "atlantis"
    elif "BL" in fw_version:
        persona = "bluering"
    elif "MM" in fw_version:
        persona = "mackinac"
    elif "ZJ" in fw_version:
        persona = "zeus"
    elif "GW" in fw_version:
        persona = "dunes"
    elif "GM" in fw_version:
        persona = "goldfinger"
    elif "SG" in fw_version:
        persona = "sidu"
    elif "BN" in fw_version:
        persona = "bluering"
    elif "BD" in fw_version:
        persona = "baja"

    return persona

def get_xml_type(device_option):
    """
    Helper function. get the equivalent xml file to be updated

    Args:
        device_option - tray or device
    Return:
        actual xml file
    """
    xmlList = {
        'Tray': 'trays.xml',
        'Device': 'output_device.xml',
    }
    xml_type = xmlList.get(device_option)
    return xml_type

def get_npa_id(device_name):
    """
    Helper function. converts the english text to its equivalent CONSTANT used in xml

    Args:
        device_name - english term
    Return:
        constant value used in xml
    """
    npa_list = {
        'Multipurpose Feeder': 'NPAMPTRAY',
        'Tray 1': 'NPATRAY1',
        'Tray 2': 'NPATRAY2',
        'Tray 3': 'NPATRAY3',
        'Tray 4': 'NPATRAY4',
        'Tray 5': 'NPATRAY5',
        'Inline finisher':'OUTPUT_DEVICE_TYPE_FINISHER',
        'Staple_Hole Punch finisher':'OUTPUT_DEVICE_TYPE_FINISHER2',
        'Stacker Bin':'OUTPUT_DEVICE_TYPE_STACKER',
        'Mailbox':'OUTPUT_DEVICE_TYPE_MAILBOX',
        'standard-capacity':'TRAY_TYPE_STANDARD',
        'optional-standard':'TRAY_TYPE_OPTIONAL_550',
        'high-capacity':'TRAY_TYPE_OPTIONAL_2000',
        'mp-and-manual':'TRAY_TYPE_COMBINED_MP_MANUAL_ENVELOPE',
        'manual-paper':'TRAY_TYPE_MANUAL_PAPER',
        'multipurpose-tray':'TRAY_TYPE_MPTRAY',
        'manual-envelope':'TRAY_TYPE_MANUAL_ENVELOPE',
        'optional-envelope':'TRAY_TYPE_OPTIONAL_ENVELOPE'
    }
    npa_id = npa_list.get(device_name)
    return npa_id
