"""
PRINTER EWS LOG UTILS
---------
"""
import os
import re
import time
import poplib
import socket
import logging
import datetime
import lxk_sentry
import subprocess
from datetime import timedelta

LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.DEBUG)

def check_exported_file(ip_address, exportformat, logfile, search_type, string):
    
    # exact format from logformat
    auditformat = { 
        "RFC5424": {
            "PRI": 1,
            "VERSION": 2,
            "TIMESTAMP": 3,
            "HOSTNAME": 4,
            "APPNAME": 5,
            "PROCID": 6,
            "MSGNAME": 7,
            "SDELEMENT": 8,
            "EVENTNAME": 9,
            "EVENTDATA": 10, 
        }   
    }
    sstring = re.split(",", string)
    tname = {}
    sdelem = {}
    for s in sstring:
        sepname = re.split("=", s, maxsplit=1)
        fieldname = re.sub("^\s+", "", sepname[0])
        fieldname = fieldname.upper()
        if fieldname == 'SDELEMENT':
            sdname = re.split("=", sepname[1], maxsplit=1)
            sdfname = re.sub("^\s+", "", sdname[0])
            sdfname = sdfname.upper()
            sdelem.update({sdfname: sdname[1]})
        else:
            tname.update({fieldname: sepname[1]})

    host = socket.gethostbyaddr(ip_address)
    hostname = host[0].split('.')
    hostname = hostname[0]

    tname.update({"HOSTNAME": hostname.upper()})
    owd = os.getcwd()
    tmpdir = os.path.dirname(logfile)
    try:
        resultsdir = os.environ["RESULTSDIR"]
        tmpdir = resultsdir
    except KeyError:
        pass
    os.chdir(tmpdir)
    newest_file = os.path.basename(logfile)
    auditfile = os.path.join(tmpdir, newest_file)
    txt = open(auditfile, "r")
    notfound = 1
    result = {}
    for line in txt:
        result = {}
        notfound = 0
        line=line.rstrip()
        if exportformat == "RFC5424":
            if 'EVENTDATA' in tname.keys():
                if line.count(":") > 2:  #there are two colons in the timestamp
                    matches = re.search("(<\d+>)(\d+) (\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z) (\w+) (\w+[\s\w]*?) (\d+) (<.+>) (\[.*?\]) (.*?:) (.*)", line)
                else:
                    matches = re.search("(<\d+>)(\d+) (\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z) (\w+) (\w+[\s\w]*?) (\d+) (<.+>) (\[.*?\]) (.*) (.*)", line)
            elif 'EVENTNAME' in tname.keys():
                if line.count(":") > 2:
                    matches = re.search("(<\d+>)(\d+) (\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z) (\w+) (\w+[\s\w]*?) (\d+) (<.+>) (\[.*?\]) (.*?:)\s*(.*)", line)
                else:
                    matches = re.search("(<\d+>)(\d+) (\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z) (\w+) (\w+[\s\w]*?) (\d+) (<.+>) (\[.*?\]) (.*)\s*(.*)", line)
            else:
                matches = re.search("(<\d+>)(\d+) (\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z) (\w+) (\w+[\s\w]*?) (\d+) (<.+>) (\[.*?\])", line)
            if matches:
                for a in tname:
                    a = a.upper() 
                    if tname[a] == matches.group(auditformat[exportformat][a]):
                        result.update({a: 1})
                if sdelem:
                    for b in sdelem:
                        b = b.upper()
                        if re.search(b+"=", matches.group(auditformat[exportformat]['SDELEMENT']), re.IGNORECASE):
                            sditem = re.split("\s+", matches.group(auditformat[exportformat]['SDELEMENT']))
                            for d in sditem:
                                sepsd = re.split("=", d, maxsplit=1)
                                if b == sepsd[0].upper():
                                    if re.search("\W*"+sdelem[b]+"\W*", sepsd[1]):
                                        result.update({b: 1})
            for a in tname:
                if not a in result.keys():
                    notfound=1
            for b in sdelem:
                if not b in result.keys():
                    notfound=1
            if notfound == 0:
                break
    txt.close()
    os.chdir(owd)
    if notfound == 1:
        if search_type == "contains":
            assert False, "File: {} does not contain {}".format(newest_file, string)
    else:
        if search_type == "does not contain":
            assert False, "File: {} does contain {}".format(newest_file, string)

def check_printer_syslog(auth_line, ip_address):
    """
        Checks printer remote syslog file(printer.log) from the hosting server
    Args:
        auth_line - expected auth line statement of log
    Return:
        True, if no errors encountered otherwise
        False plus error statements
    """

    if lxk_sentry.LxkSentry().is_run_in_sentry():
        create_qemu_user("test")
        return check_syslog(auth_line, ip_address)
    else:
        return check_syslog(auth_line, ip_address)

def create_qemu_user(username):
    """
        Create temporary username in qemu tester
    Args:
        username - user to create
    """

    # Add user in qemu tester
    addUser_cmd = '''useradd ''' + username
    p = subprocess.Popen(addUser_cmd, stdout=subprocess.PIPE,stderr=subprocess.PIPE, shell=True)
    return_out, errors = p.communicate()
    LOGGER.debug(return_out)
    LOGGER.debug(errors)
    LOGGER.debug("\n")
    # Copy ssh keys from /home/root/.ssh
    copySSHkeys_cmd = '''cp -r /home/root/.ssh/ /home/''' + username + '''/.ssh'''
    p = subprocess.Popen(copySSHkeys_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    return_out, errors = p.communicate()
    LOGGER.debug(return_out)
    LOGGER.debug(errors)
    LOGGER.debug("\n")
    # Change owner to user
    changeOwner_cmd = '''chown ''' + username + ''' /home/''' + username + '''/.ssh -R'''
    p = subprocess.Popen(changeOwner_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    return_out, errors = p.communicate()
    LOGGER.debug(return_out)
    LOGGER.debug(errors)
    LOGGER.debug("\n")


def check_syslog(auth_line, ip_address):
    """
        Check content printer log file from the hosting server
    Args:
        auth_line - expected auth line statement of log
    Return:
        True, if no errors encountered otherwise
        False plus error statements
    """

    host = socket.gethostbyaddr(ip_address)
    hostname = host[0].split('.')
    hostname = hostname[0]

    hostname_value_handle = hostname.upper()

    output = ""
    try:
        if lxk_sentry.LxkSentry().is_run_in_sentry():
            cmd = 'ssh -l test ubuntusrv01.opensrc.security.lrdc.lexmark.com "cd /var/log ; cat printer3.log"'
        else:
            cmd = 'ssh test@ubuntusrv01.opensrc.security.lrdc.lexmark.com "cd /var/log ; cat printer3.log"'

        LOGGER.debug(cmd)
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, error) = p.communicate()
        LOGGER.debug("\nError: \n", error)
        LOGGER.debug("\nOutput: \n", output)

        LOGGER.debug(output.decode("utf-8"))
        res= output.decode("utf-8")
        if hostname_value_handle in res and auth_line in res:
            LOGGER.debug("\nSuccessfully verified in the log")
            LOGGER.debug("Hostname: ", hostname_value_handle)
            LOGGER.debug("Auth line: ", auth_line)
            return True, "Found in logs"
        else:
            return False, "Failed: not seen in the logs..."

    except:
        return False, "Fatal error: connection refuse..."
    

def store_recent_emails_audit_log(num_emails, audit_log_emails):
    """ Store a number of emails from the server, 
    which can be manually accessed via the following details:
    URL Current: msdn-sniper-app.lxc2008.security.lrdc.lexmark.com
    URL Old: msdn-zeus-dc.lxc2008.security.lrdc.lexmark.com
    Username: LXC2008\ademail
    Password: ademail1
    Args:
        num_emails - number of emails to store. This needs to be converted to int first
    Return:
        None
    """
    email_limit_count = int(num_emails)
    logpath ="logs"
    os.environ['RESULTSLOGPATH'] = logpath
    try:
        if os.environ["RESULTSLOGPATH"] == "logs":
            resultsdir = os.environ["RESULTSDIR"]
        else:
            resultsdir = os.environ["RESULTSDIR"] + "/" + os.environ["RESULTSLOGPATH"]
    except KeyError:
        resultsdir = str(os.getcwd()) + "/{}/".format(os.environ["RESULTSLOGPATH"])

    email_filename = os.path.join(resultsdir, "email_log.log")

    f = open(email_filename, "w")

    if email_limit_count > 0:
        M = poplib.POP3_SSL("msdn-sniper-app.lxc2008.security.lrdc.lexmark.com", 995)
        M.user("LXC2008\\ademail")
        M.pass_("ademail1")
        numMessages = len(M.list()[1])  
        #1 is the number of the oldest message on the server; the higher the number, 
        #the more recent the message
        for i in range(numMessages, max(0, numMessages-email_limit_count),-1):

            raw_email  = b"\n".join(M.retr(i)[1])
            audit_log_emails.append(raw_email.decode("utf-8"))
            f.write(audit_log_emails[-1])
            f.write("\n################################################################################\n")
        M.quit()
    f.close()


def verify_recent_emails_audit_log(time_limit, email_contents, ip_address, audit_log_emails):
    """ Check if at least one of the stored e-mails meets the provided criteria.
    Args:
        time_limit - number of minutes within which the message was sent
        email_contents - contents to check for in a message. Each field is separated by "|"
    Return:
        True if a stored message meets all criteria; Otherwise, False
    """
    success = False
    msg = "ErrMsg: The provided list contains '{0}', but none of the stored e-mails match the list. \
    Please refer to email_log.log in the logs folder".format(email_contents)
    email_contents_list = email_contents.split("|")

    try:
        time_limit = int(time_limit)
    except ValueError:
        msg = "ErrMsg: The time limit provided was '{0}', which is not a valid integer"\
        .format(time_limit)
        return (success, msg)

    host = socket.gethostbyaddr(ip_address)
    hostname = host[0].split('.')
    hostname = hostname[0].upper()

    email_contents_list.append("{0}.dhcp.lrdc.lexmark.com ({1})".format(hostname, ip_address))  
    #message also contains this line, which must also be checked

    current_utc_time = datetime.datetime.utcnow()

    for email in audit_log_emails:
        message = email
        boundary_strings = []
        current_message = []

        #Check the time
        email_date = ""
        email_date_timezone = ""
        timezone_hour = 0
        timezone_minute = 0

        msgLines = message.split("\n")

        for line in msgLines:
            current_message.append(line)  #keep appending to current message
            if line.startswith("Date:"):
                comma_index = line.find(",")
                if comma_index != -1:
                    email_date = line[comma_index+1:-5].strip()
                else:
                    email_date = line[:-5].strip()
                email_date_timezone = line[-5:].strip()
                timezone_hour = int(email_date_timezone[:3])
                timezone_minute = int(email_date_timezone[3:])
            elif line.startswith("\tboundary="):
                # Check if valid boundary; valid boundary would have double quotes on both sides
                boundary_value = line[10:]
                if boundary_value.startswith('"') and boundary_value.endswith('"'):
                    # Valid boundary value
                    boundary_strings.append(boundary_value.strip('"'))
            elif line.startswith("MIME-Version: 1.0"):
                # last line of the header
                break
        

        utc_offset_in_seconds = abs(timezone_hour*3600) + abs(timezone_minute*60)

        if timezone_hour < 0:
            utc_offset_in_seconds = -utc_offset_in_seconds

        time_offset = timedelta(seconds=utc_offset_in_seconds)
        date_format = "%d %b %Y %H:%M:%S"
        formatted_date = datetime.datetime.strptime(email_date, date_format) - time_offset
        time_difference = (current_utc_time - formatted_date).total_seconds()

        if time_difference > time_limit*60:  #the message exceeded the time
            msg = "ErrMsg: The provided time limit of '{0}' minutes was exceeded. \
            Please refer to email_log.log in the logs folder".format(time_limit)
            break  

        message_start_index = message.index("MIME-Version: 1.0")
        message_body = message[message_start_index+1:]

        message_frame = []
        message_packet = []
        multiline_message = []

        message_body = message_body.split("\n")
        for line in message_body:
            if line.startswith("--"):
                # Found a boundary
                if message_packet:  #cannot extend blank packet
                    message_frame.extend(message_packet)
                    message_packet = []  #reset packet

                while boundary_strings and boundary_strings[-1] not in line:
                    # Wrong boundary; need to keep popping until proper boundary is found
                    boundary_strings.pop()

                if boundary_strings:  #boundary_strings still has a value; that value also matches in line
                    # Correct boundary found
                    if line.endswith("--"):
                        # Last instance of boundary; need to pop; proceed to new frame
                        boundary_strings.pop()
                        if message_frame:
                            current_message.extend(message_frame)
                            message_frame = []
            elif line.startswith("\tboundary"):
                boundary_value = line[10:]
                if boundary_value.startswith('"') and boundary_value.endswith('"'):
                    # Valid boundary value
                    boundary_strings.append(boundary_value.strip('"'))
            elif line.endswith("="):
                multiline_message.append(line)
            else:
                if multiline_message:
                    multiline_message.append(line)  #line is now the last part needed for multiline_message
                    multiline_message = [item.rstrip("=").replace("=0A", "\n") for item in multiline_message]
                    multiline_message = "".join(multiline_message).splitlines()  #separate by newline
                    message_packet.extend(multiline_message)
                    multiline_message = []
                else:
                    message_packet.append(line)

        if message_packet:
            message_frame.extend(message_packet)
            message_packet = []

        if message_frame:
            current_message.extend(message_frame)
            message_frame = []

        message = current_message

        #check the actual message
        if all(item.strip() in message for item in email_contents_list):
            success = True
            msg = "An e-mail that has met all criteria has been found"
            break

    return (success, msg)