"""
EVENT LOG
---------
"""

import os
import re
import json
import time
import logging
import datetime
from lxk_testlib import rob

LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.DEBUG)

def store_last_entry_of_json_file_key_value_pairs(filename, key_value_pairs, prefix, event_log_data, event_log_searches):
    """
    Return:
        True if successfully saved; False otherwise
    """
    success = False
    msg = "ErrMsg: Key-value pairs were malformed"

    kv_dict = {}

    if key_value_pairs:  #Possible empty field
        key_value_pairs = key_value_pairs.split("|")
        for kv in key_value_pairs:
            kv = kv.split(":")
            if len(kv) < 2:
                return (success, msg)
            else:
                kv_dict[kv[0].strip()] = kv[1].strip()

    msg = "ErrMsg: Could not read the JSON file"
    filename = get_savepath_if_sentry(filename)
    with open(filename, "r") as f:

        data = f.read().splitlines()[::-1]

        for d in data:
            d = json.loads(d)
            found_match = True
            for key, value in kv_dict.items():
                if not verify_json(d, key, value):
                    found_match = False
                    break

            if found_match:
                event_log_data = d
                event_log_searches.update(save_all_key_value_pairs(event_log_data, prefix))

                print(json.dumps(event_log_data, indent=1, sort_keys=True))
                print("\n")
                LOGGER.debug(json.dumps(event_log_data, indent=1, sort_keys=True))
                LOGGER.debug(event_log_searches)

                success = True
                msg = "Saved the last record"
                break
        else:
            if not success:
                msg = "ErrMsg: Could not find the record that matched the key-value pairs"

    return (success, msg)

def store_first_entry_events_of_json_file_key_value_pairs(filename, key_value_pairs, prefix, event_log_data, event_log_searches):
    """
    Return:
        True if successfully saved; False otherwise
    """
    success = False
    msg = "ErrMsg: Key-value pairs were malformed"

    kv_dict = {}

    if key_value_pairs:  #Possible empty field
        key_value_pairs = key_value_pairs.split("|")
        for kv in key_value_pairs:
            kv = kv.split(":")
            if len(kv) < 2:
                return (success, msg)
            else:
                kv_dict[kv[0].strip()] = kv[1].strip()

    msg = "ErrMsg: Could not read the JSON file"
    filename = get_savepath_if_sentry(filename)
    with open(filename, "r") as f:
        json_data = json.loads(f.read())

        data = json_data["Events"]

        msg = "ErrMsg: Could not find a record that matched the key-value pairs"

        for d in data:
            found_match = True
            for key, value in kv_dict.items():
                if not verify_json(d, key, value):
                    found_match = False
                    break

            if found_match:
                event_log_data = d
                event_log_searches.update(save_all_key_value_pairs(event_log_data, prefix))

                print(json.dumps(event_log_data, indent=1, sort_keys=True))
                print("\n")
                LOGGER.debug(json.dumps(event_log_data, indent=1, sort_keys=True))
                LOGGER.debug(event_log_searches)

                success = True
                msg = "Saved the first record"
                break

    return (success, msg)

def get_savepath_if_sentry(filename):
    '''
    Once the test is run in sentry the file should be save or get from RESULTSDIR
    
    Return:
    - path
    '''
    savefile = filename
    try:
        if os.environ['RESULTSLOGPATH'] == 'logs':
            resultsdir = os.environ["RESULTSDIR"]
        else:
            resultsdir = os.environ["RESULTSDIR"] + "/" + os.environ['RESULTSLOGPATH']
        if os.path.isabs(filename):
            filename = os.path.basename(filename)
        else:
            if re.search("/", filename):
                filename = os.path.basename(filename)
        savefile = resultsdir + "/" + filename
    except KeyError:
        pass
    print ("filename = %s" % savefile)
    return savefile

def verify_json(json_data, key_field, value_field):
    """Search for a key in the JSON data and check its value with the given parameter

    Return:
        True if the key was found and its value matched the given value_field; False otherwise
    """
    success = False

    for key, value in json_data.items():
        if isinstance(value, dict):
            success = verify_json(value, key_field, value_field)
        elif isinstance(value, list):
            for i in value:
                if isinstance(i, dict):
                    success = verify_json(i, key_field, value_field)
                    if success:
                        break
        else:
            if key == key_field:
                if value == value_field:
                    success = True
                    break  #once the key has been found, no need to keep searching


    return success

def search_in_json(json_data, key_field, title, event_log_searches):
    """Search for a key in the JSON data and store the value under the given title

    Return:
        True if the key was found and its value saved; False otherwise
    """
    success = False
    msg = "ErrMsg: Could not find the correct data."

    for key, value in json_data.items():
        if isinstance(value, dict):
            success, msg = search_in_json(value, key_field, title, event_log_searches)
        elif isinstance(value, list):
            for i in value:
                if isinstance(i, dict):
                    success, msg = search_in_json(i, key_field, title, event_log_searches)
                    if success:
                        break
        else:
            if key == key_field:
                event_log_searches[title] = value
                success = True
                msg = "Saved under '{0}'".format(title)
                break  #once the key has been found, no need to keep searching

    return (success, msg)

def save_all_key_value_pairs(json_data, prefix):
    """Save all the key-value pairs in the provided JSON data. The prefix may be used to prevent data from being overwritten

    Args:
        json_data - data to search for the key
        prefix - string to prepend to each key that does not have a dict as its value. There is a space that divides the prefix with the key
    Return:
        dict containing all keys with non-dict values, and this dict may be empty
    """
    d = {}

    for key, value in json_data.items():
        if isinstance(value, dict):
            d.update(save_all_key_value_pairs(value, prefix))
        elif isinstance(value, list):
            for i in value:
                if isinstance(i, dict):
                    d.update(save_all_key_value_pairs(i, prefix))
        else:
            if prefix:
                d[prefix+" "+key] = value
            else:
                d[key] = value

    return d

def check_item_format_in_stored_entry(title, format_style, event_log_searches):
    """Check the format of the value of the searched key in the stored entry/

    Args:
        title - string the data was saved under
        format_style - "unsigned integer" checks if it is an unsigned integer. 
                       "timestamp" checks if it follows a format similar to: 2017-02-15T19:41:24-0500. 
                       "uptime" checks if format is HH:MM:SS.
    Return:
        True if successfully matched; False otherwise
    """
    success = False
    msg = ""
    if title in event_log_searches:
        msg = "ErrMsg: The stored value is '{0}', but it is not in the desired format".format(event_log_searches[title])
        value = event_log_searches[title]
        if format_style == "unsigned integer":
            if isinstance(value, str):
                try:
                    value = int(value)
                except:
                    pass
            if isinstance(value, (int, long)) and value >= 0:
                success = True
                msg = "The value is indeed an unsigned integer"
        elif format_style == "timestamp":
            if isinstance(value, str):
                split_by_t = value.split("T")
                year_month_day = split_by_t[0].split("-")
                hour_minute_second_timezone = split_by_t[1].split(":")
                second = hour_minute_second_timezone[2][:2]
                timezone = hour_minute_second_timezone[2][2:]

                msg = ""
                try:
                    datetime.datetime.strptime(year_month_day[0], "%Y")
                except ValueError:
                    msg += "The year '{0}' is not the correct format\n".format(year_month_day[0])
                try:
                    datetime.datetime.strptime(year_month_day[1], "%m")
                except ValueError:
                    msg += "The month '{0}' is not the correct format\n".format(year_month_day[1])
                try:
                    datetime.datetime.strptime(year_month_day[2], "%d")
                except ValueError:
                    msg += "The day '{0}' is not the correct format\n".format(year_month_day[2])
                try:
                    datetime.datetime.strptime(hour_minute_second_timezone[0], "%H")
                except ValueError:
                    msg += "The hour '{0}' is not the correct format\n".format(hour_minute_second_timezone[0])
                try:
                    datetime.datetime.strptime(hour_minute_second_timezone[1], "%M")
                except ValueError:
                    msg += "The minute '{0}' is not the correct format\n".format(hour_minute_second_timezone[1])
                try:
                    datetime.datetime.strptime(second, "%S")
                except ValueError:
                    msg += "The second '{0}' is not the correct format\n".format(second)

                if timezone[0] == "+" or timezone[0] == "-":
                    try:
                        datetime.datetime.strptime(timezone[1:3], "%H")
                    except ValueError:
                        msg += "The hour in the timezone '{0}' is not the correct format\n".format(timezone[1:3])
                    try:
                        datetime.datetime.strptime(timezone[3:], "%M")
                    except ValueError:
                        msg += "The minute in the timezone '{0}' is not the correct format\n".format(timezone[3:])
                else:
                    msg += "The timezone '{0}' does not start with + or -\n".format(timezone)

                if msg == "":
                    success = True
                    msg = "The value is indeed in the correct timestamp format"
                else:
                    msg = "ErrMsg: " + msg
        elif format_style == "uptime":
            if isinstance(value, str):
                split_by_colon = value.split(":")
                if len(split_by_colon) == 3:
                    if int(split_by_colon[0]) >= 0:
                        print("Hours")
                        if 0<= int(split_by_colon[1]) <=59:
                            if 0<= int(split_by_colon[2]) <=59:
                                success = True
                                msg = "Uptime is Valid"
                            else:
                                msg = "ErrMsg: Uptime Invalid SS"
                        else:
                            msg = "ErrMsg: Uptime Invalid MM"
                    else:
                        msg = "ErrMsg: Uptime Invalid HH"
                else:
                    msg = "ErrMsg: Uptime Invalid EE"
            else:
                msg = "ErrMsg: Uptime Invalid"
    else:
        msg = "ErrMsg: There is no data stored under '{0}'".format(title)

    return (success, msg)

def check_item_with_item(title1, title2, event_log_searches):
    """Check the value saved under a title or label with the value saved in another title or label

    Return:
        True if successfully checked; False otherwise
    """

    success = False
    if title1 in event_log_searches and title2 in event_log_searches:
        msg = "ErrMsg: The value found under '{0}' is '{1}', while the value found under '{2}' is '{3}'".format(title1, event_log_searches[title1],title2, event_log_searches[title2])
        if str(event_log_searches[title1]) == str(event_log_searches[title2]):
            success = True
            msg = "The values match"
        else:
            title1_lower = title1.lower()
            title2_lower = title2.lower()
            if "time" in title1_lower and "time" in title2_lower and "up" not in title1_lower and "up" not in title2_lower:
                time_strings = [str(event_log_searches[title1]), str(event_log_searches[title2])]
                for i, t in enumerate(time_strings):
                    if "T" in t:
                        t = t[:-5]  #remove the UTC offset
                        time_strings[i] = datetime.datetime.strptime(t, "%Y-%m-%dT%H:%M:%S")
                    else:  #for Event Log Summary
                        time_strings[i] = datetime.datetime.strptime(t, "%b %d %H:%M:%S %Y")
                if time_strings[0] == time_strings[1]:
                    success = True
                    msg = "The values match"
    else:
        msg = "ErrMsg:"
        if title1 not in event_log_searches:
            msg += "There is no data stored under '{0}'\n".format(title1)
        if title2 not in event_log_searches:
            msg += "There is no data stored under '{0}'\n".format(title2)

    return (success, msg)

def check_item_in_stored_entry(title, value_field, event_log_searches):
    """Check the value of the searched key in the stored entry.

    Return:
        True if successfully matched; False otherwise
    """
    success = False
    msg = ""
    if title in event_log_searches:
        msg = "ErrMsg: The provided value was '{0}', but the actual value is '{1}'".format(value_field, event_log_searches[title])
        if str(event_log_searches[title]) == str(value_field):
            success = True
            msg = "The values match"
    else:
        msg = "ErrMsg: There is no data stored under '{0}'".format(title)

    return (success, msg)

def get_item_in_stored_entry(key_field, title, event_log_data, event_log_searches):
    """Get the value of a given key in the stored entry.
    
    Return:
        True if successfully found; False otherwise
    """
    success = False
    msg = "ErrMsg: Could not search report data"

    success, msg = search_in_json(event_log_data, key_field, title, event_log_searches)

    print(event_log_searches[title])
    print("\n")

    return (success, msg)

def check_if_item_in_stored_entry(title, event_log_searches):
    """Check if the value of the searched key exists in the stored entry.

    Return:
        True if exists; False otherwise
    """
    success = False
    msg = ""
    if title in event_log_searches:
        success = True
        msg = "The value was found"
    else:
        msg = "ErrMsg: There is no data stored under '{0}'".format(title)

    return (success, msg)

def calculate_sum(title1, title2, title3, event_log_searches):
    """Calculate the sum of the value saved under a title or label and the value saved in another title or label

    Return:
        True if successfully checked; False otherwise
    """
    success = False
    if title1 in event_log_searches and title2 in event_log_searches:
        msg = "ErrMsg: The value found under '{0}' is '{1}', while the value found under '{2}' is '{3}'".format(title1, event_log_searches[title1],title2, event_log_searches[title2])
        event_log_searches[title3] = int(event_log_searches[title1]) + int(event_log_searches[title2])
        success = True
        msg = "The values were added"
    else:
        msg = "ErrMsg:"
        if title1 not in event_log_searches:
            msg += "There is no data stored under '{0}'\n".format(title1)
        if title2 not in event_log_searches:
            msg += "There is no data stored under '{0}'\n".format(title2)

    return (success, msg)

def save_event_log_to_file(filename, event_log_searches):
    """Save the event log data to the specified file

    Return:
        True if successfully saved; False otherwise
    """
    success = False
    msg = "ErrMsg: Could not save to file '{0}'".format(filename)
    with open(filename, "w") as outfile:
        json.dump(event_log_searches, outfile, indent=1, sort_keys=True)
        success = True
        msg = "Successfully saved to file '{0}'".format(filename)

    return (success, msg)

def clear_eventlog(ip_address):
    success = False
    msg = "Problem executing rob command"

    cmd = "call applications.eventlog clearLog {}"
    LOGGER.debug(cmd)
    return_output = rob.execute(ip_address, cmd)
    LOGGER.debug(return_output)
    if "rc = PROXY_OK" in return_output[1]:
        success = True
        msg = "Successfully executed rob command \n"
    
    return (success, msg)