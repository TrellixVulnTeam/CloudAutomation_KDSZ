from robot.libraries.BuiltIn import BuiltIn
from robot.api import logger
from pysnmp.proto.rfc1902 import *
from pysnmp.proto.rfc1905 import *
import os
import csv
import random
import string


GET = lambda var, default=None: BuiltIn().get_variable_value(name=var,
                                                            default=default)


class SnmpCsv:

    ROBOT_LIBRARY_SCOPE = "TEST SUITE"

    def __init__(self):
        self.wd = os.path.dirname(os.path.realpath(__file__))
        self.type_str_list = ['DisplayString', 'TimeStamp', 'OctetString']
        self.type_obj_list = ['ObjectIdentity', 'ObjectIdentifier', 'IpAddress']
        self.type_int_list = ['Integer32', 'Integer', 'Gauge32', 'Counter32',
                            'Counter64', 'TimeTicks', 'TestAndIncr',
                            'Unsigned32']

    def _get_oids_file(self, csvfile):
        '''
        Create oids dictionary from csvfile
        :param csvfile:
        '''
        oid_dict = {}

        if not os.path.exists(csvfile):
            raise AssertionError("\'{}\' file not found.".format(csvfile))
        else:
            with open(csvfile,encoding='utf-8-sig') as fh:
                reader = csv.DictReader(fh)
                for r in reader:
                    oid_dict[r['oid'].strip()] = {k:r[k] for k in r if k
                                                not in ['oid']}
                    for d in oid_dict:
                        for e in oid_dict[d]:
                            dyna_var = self._if_nonetype(oid_dict[d][e]).strip()
                            if dyna_var.startswith("\\${"):
                                oid_dict[d][e] = GET(oid_dict[d][e].strip())

        return oid_dict

    def _check_oid_exists(self, oid_dict, oid_attr):
        '''
        Check if oid exists
        :param oid_dict:
        :param oid_attr:
        '''
        exist_error_str = ''
        count_error = 0
        data_type = self._if_nonetype(oid_attr['data_type'])
        chk_exist = self._if_nonetype(oid_dict['check_if_exists']
                                    ).strip().upper()

        if (chk_exist ==  'TRUE' and
            data_type == 'NoSuchInstance'): # check if [exists] is set to TRUE
            count_error += 1
            exist_error_str += '<OID DOES NOT EXIST>'
        elif (chk_exist !=  'TRUE' and
            data_type != 'NoSuchInstance'): # check if [exists] is not set
            count_error += 1
            exist_error_str += '<OID EXISTS>'
        else:
            pass

        return exist_error_str

    def _check_oid_dict_val(self, oid_dict, oid_attr):
        '''
        Check expected vs actual oid value
        :param oid_dict:
        :param oid_attr:
        '''
        val_error_str = ''
        count_error = 0
        expected_value = self._if_nonetype(oid_dict['expected_value'])
        acquired_value = self._if_nonetype(oid_attr['value'])
        chk_exp_val = self._if_nonetype(
                            oid_dict['check_expected_value']).strip().upper()

        if (chk_exp_val ==  'TRUE' and
            expected_value != acquired_value):
            count_error += 1
            val_error_str += (
                '<GIVEN VALUE OF "{}" IS NOT EQUAL TO "{}">'.format(
                                                expected_value, acquired_value))
        else:
            pass

        return val_error_str

    def _check_oid_dict_type(self, oid_dict, oid_attr):
        '''
        Check expected vs actual oid type
        :param oid_dict:
        :param oid_attr:
        '''
        type_error_str = ''
        count_error = 0
        data_type = self._if_nonetype(oid_dict['data_type'])
        acquired_data_type = self._if_nonetype(oid_attr['data_type'])
        check_data_type = self._if_nonetype(
                            oid_dict['check_data_type']).strip().upper()

        if (check_data_type ==  'TRUE' and
            data_type != acquired_data_type):
            count_error += 1
            type_error_str += (
                '<GIVEN TYPE OF "{}" IS NOT EQUAL TO "{}">'.format(
                                                data_type, acquired_data_type))
        else:
            pass

        return type_error_str

    def _check_oid_dict_rw(self, oid_full, oid_dict, oid_attr):
        '''
        Return random value to write
        :param oid_full:
        :param oid_dict:
        :param oid_attr:
        '''
        rw_error_str = ''
        data_to_write = '_NONE_'
        curr_oid_val = self._if_nonetype(oid_attr['value'])
        curr_oid_type = self._if_nonetype(oid_attr['data_type'])
        rw_access = self._if_nonetype(oid_dict['rw_access']).strip().upper()
        check_rw_access = self._if_nonetype(
                            oid_dict['check_rw_access']).strip().upper()
        set_oid_attr = [curr_oid_val, curr_oid_type]
        set_err = ['REQ_ERROR', 'REQ_NOTFOUND',
                    'REQ_TIMEOUT', 'NoSuchInstance']
        given_range = self._if_nonetype(oid_dict['value_range'])

        if (check_rw_access ==  'TRUE'):
            # check acquired values first
            if set(set_oid_attr).intersection(set(set_err)):
                rw_error_str = '<RW, ERROR ACQUIRING OID ATTRIBUTES>'
            else:
                # change data according to data type [INTEGERS]
                if curr_oid_type in self.type_int_list:
                    # check if there is given value_range
                    if len(given_range.strip()) == 0: # no given range
                        if len(curr_oid_val) == 0: # no queried value
                            data_to_write = 1
                        else: # randomize set value
                            r = [*range(0, 10, 1)]
                            n =  int(curr_oid_val[-1])
                            r.remove(n)
                            rand_val = random.choice(r)
                            data_to_write = int(curr_oid_val[:-1]
                                                + str(rand_val))
                    else:
                        val_range = self._get_val_range(given_range,
                                                        curr_oid_type)
                        # check for input value range errors
                        if 'ERROR' in val_range:
                            rw_error_str = val_range
                        else:
                            try:
                                val_range.remove(int(curr_oid_val))
                            except:
                                pass
                            rand_val = 1
                            if len(val_range) != 0:
                                rand_val = random.choice(val_range)
                            else:
                                rw_error_str = (
                                    '<CHECK GIVEN RANGE \'{}\'>'.format(
                                                        given_range.strip()))
                            data_to_write =  rand_val
                # change data according to data type [STRINGS]
                elif curr_oid_type in self.type_str_list:
                    # check if there is given value_range
                    if len(given_range.strip()) == 0: # no given range
                        if len(curr_oid_val) == 0: # no queried value
                            data_to_write = 'a'
                        else: # randomize set value
                            r =  [i for i in string.printable]
                            n =  curr_oid_val[-1]
                            try:
                                r.remove(n)
                            except:
                                pass
                            rand_val = random.choice(r)
                            data_to_write = '{}{}'.format(curr_oid_val[:-1],
                                                        rand_val)
                    else:
                        val_range = self._get_val_range(given_range,
                                                        curr_oid_type)
                        # check for input value range errors
                        if 'ERROR' in val_range:
                            rw_error_str = val_range
                        else:
                            try:
                                val_range.remove(curr_oid_val)
                            except:
                                pass
                            rand_val = random.choice(val_range)
                            data_to_write =  rand_val
                # change data according to data type [OBJ or MISC]
                elif curr_oid_type in self.type_obj_list:
                    if len(given_range.strip()) == 0: # no given range
                        if len(curr_oid_val) == 0: # no queried value
                            data_to_write = '0.0.0.0'
                        else: # randomize set value
                            r = [*range(0, 10, 1)]
                            n =  int(curr_oid_val.strip()[-1])
                            try:
                                r.remove(n)
                            except:
                                pass
                            rand_val = random.choice(r)
                            # r_new = r.remove(n)
                            data_to_write = '{}{}'.format(
                                                curr_oid_val.strip()[:-1],
                                                rand_val)
                    else:
                        pass  # can't really specify range
                else:
                    pass

        return rw_error_str, data_to_write, rw_access

    def _get_val_range(self, val_range, oid_type):
        '''
        Return a range list
        :param val_range:
        :param oid_type:
        '''
        range_final = []

        try:
            if '-' in val_range and oid_type in self.type_int_list:
                val_list = ''.join(val_range.split()).split('-')
                val_list = [int(i) for i in val_list]
                min_val = int(min(val_list))
                max_val = int(max(val_list))
                range_final = [*range(int(min_val), int(max_val) + 1, 1)]
            elif ',' in val_range and oid_type in self.type_int_list:
                range_temp = ''.join(val_range.split(','))
                range_final = [int(i) for i in range_temp]
            elif oid_type in self.type_int_list:
                min_val = 0
                max_val = int(val_range)
                range_final = [*range(min_val, max_val + 1, 1)]
            elif '|' in val_range and oid_type in self.type_str_list:
                range_final = val_range.split('|')
            else:
                range_final = val_range
        except Exception as e:
            range_final = '<ERROR IN GIVEN RANGE \'{}\' {}>'.format(
                                                                range_final,
                                                                e)

        return range_final

    def _if_nonetype(self, value):
        '''
        Convert NoneType value to blank string
        :param value:
        '''
        if value is None:
            value_ret = ''
        else:
            value_ret = value

        return value_ret

    def _switch_type(self, oid_type, input_oid_val):
        '''
        Convert oid value to specified type
        :param oid_type:
        :param input_oid_val:
        '''
        oid_val_str = '{}'.format(input_oid_val)
        oid_val_int = 0
        oid_val_ip = '0.0.0.0'
        oid_val_obj = '.0'

        if oid_type == 'IpAddress':
            oid_val_ip = '{}'.format(input_oid_val)

        if oid_type in self.type_obj_list:
            oid_val_obj = '{}'.format(input_oid_val)

        if oid_type in self.type_int_list:
            oid_val_int = int(input_oid_val)

        switcher = {
            'DisplayString' : OctetString(oid_val_str),
            'ObjectIdentity': ObjectIdentifier(oid_val_obj),
            'TimeTicks': TimeTicks(oid_val_int),
            'Integer32': Integer32(oid_val_int),
            'TimeStamp': OctetString(oid_val_str),
            'Integer': Integer(oid_val_int),
            'OctetString': OctetString(oid_val_str),
            'Gauge32': Gauge32(oid_val_int),
            'Counter32': Counter32(oid_val_int),
            'ObjectIdentifier': ObjectIdentifier(oid_val_obj),
            'IpAddress': IpAddress(oid_val_ip),
            'Counter64': Counter64(oid_val_int),
            'TestAndIncr': OctetString(oid_val_str)
        }
        return switcher.get(oid_type, OctetString(oid_val_str))

if __name__ == '__main__':
    sn = SnmpCsv()
    print(sn._get_oids_file('oids.csv'))


