""" Panel Navigation States.
The state machine allows panel navigation to follow the traversal based on
UPS actions. It always start with State.Start() and end with State.End().
"""

import time
import logging
from urllib.error import URLError
from urllib.request import Request, urlopen
from lxk_testlib.panelnav.core import exceptions
from lxk_testlib.panelnav.core.enum import Action
from lxk_testlib.panelnav.core.models.state import State

LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.DEBUG)
MIN_INTERVAL = 0.25 # minimum delay between statemachine executions

class Start(State):
    """ Just an empty state.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        LOGGER.debug(State.panel.screen)

    def next(self):
        """ Return next state.
        """
        return Delay()

class Delay(State):
    """ Add delay between navigations.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        interval = time.time() - State.timestamp
        if interval < MIN_INTERVAL:
            # calculate remaining delay needed
            delay = MIN_INTERVAL - interval
            LOGGER.debug(delay)
            time.sleep(delay)

    def next(self):
        """ Return next state.
        """
        return DetermineTraversal()

class DetermineTraversal(State):
    """ Determine next state based on value of State.pending_screen which will be
    set at the end of each navigation.
    """

    def __init__(self):
        self.nextstate = None

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        LOGGER.debug(State.pending_screen)
        if State.pending_screen == "HOME":
            self.nextstate = ResetTraversal
        elif State.pending_screen:
            self.nextstate = VerifyTraversal
        else:
            self.nextstate = DetermineUPSAction

    def next(self):
        """ Return next state.
        """
        return self.nextstate()

class ResetTraversal(State):
    """ Previous navigation wants to reset traversal.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        State.panel.reset_traversal()
        LOGGER.debug(State.panel.screen)

    def next(self):
        """ Return next state.
        """
        return DetermineUPSAction()

class VerifyTraversal(State):
    """ Previous navigation wants to move traversal forward. Before that, verify
    if State.pending_screen locator marker is visible. If visible, continue with
    traversal otherwise skip it.
    """

    def __init__(self):
        self.nextstate = None

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        pending_screen = State.panel.screen.get_locator(State.pending_screen)
        LOGGER.debug(pending_screen.popup_screen)
        if pending_screen.popup_screen:
            self.nextstate = ExecuteTraversal
            return

        if pending_screen.next_screen is None:
            self.nextstate = DetermineUPSAction
            return

        locator_marker = pending_screen.next_screen.marker
        LOGGER.debug(locator_marker)
        if locator_marker is None:
            self.nextstate = DetermineUPSAction
            return

        try:
            locator_phrase = pending_screen.next_screen.get_locator(
                locator_marker
            ).get_phrase(
                filters=[State.function, State.color, State.family]
            )
        except exceptions.KeywordArgVTextRequired as err:
            msg = "Locator <%s> should not contain variable text." % (
                locator_marker
            )
            raise exceptions.NextScreenMarkerError(msg)

        action_phrase = State.action.get_action(Action.VERIFY_WIDGET_FOUND).\
            get_panelsize(State.panel_size).get_phrase()
        step = "%s %s" % (
            locator_phrase.strip(),
            action_phrase.strip()
        )
        LOGGER.debug(step)
        try:
            State.return_value = State.ups.regex(step)
            self.nextstate = ExecuteTraversal
        except ValueError as err:
            LOGGER.debug("Marker Verification Failed")
            LOGGER.debug(err)
            self.nextstate = DetermineUPSAction

    def next(self):
        """ Return next state.
        """
        return self.nextstate()

class ExecuteTraversal(State):
    """ Traverse Forward.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        State.panel.traverse_forward(State.pending_screen)
        State.pending_screen = None
        LOGGER.debug(State.panel.screen)

    def next(self):
        """ Return next state.
        """
        return DetermineUPSAction()

class DetermineUPSAction(State):
    """ A UPS Action may not necessarily contain a Locator. If a locator is
    present, proceed to executing it together with the given action.
    Otherwise, execute the action alone.
    """

    def __init__(self):
        self.nextstate = None

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        if locator:
            if action is Action.PRESS_KEY_COMBINATION:
                # non-UPS special action
                self.nextstate = ExecutePressKeyCombinationAction
            else:
                self.nextstate = ExecuteActionWithLocator
        else:
            self.nextstate = ExecuteActionOnly

    def next(self):
        """ Return next state.
        """
        return self.nextstate()

class ExecutePressKeyCombinationAction(State):
    """ Execute consecutively pressing of keys, particularly used to enter
    SE and Diagnostics menus.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        LOGGER.debug(State.panel.screen)

        assert action is Action.PRESS_KEY_COMBINATION, action
        hardkeys = State.panel.screen.get_locator(locator)\
            .get_action_specifier(action)
        LOGGER.debug(hardkeys)

        assert isinstance(hardkeys, str), type(hardkeys)
        hardkeys_list = [hardkey.strip() for hardkey in hardkeys.split(",")]

        steps = []
        for hardkey in hardkeys_list:
            action_phrase = State.action.get_action(action).\
                get_panelsize(State.panel_size).get_phrase(hardkey)
            steps.append(action_phrase)

        for step in steps:
            LOGGER.debug(step)
            State.return_value = State.ups.regex(step)

    def next(self):
        """ Return next state.
        """
        return DeterminePopupReset()

class ExecuteActionWithLocator(State):
    """ Execute UPS Action with Locator.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        LOGGER.debug(State.panel.screen)

        wait_actions = [Action.WAIT_UNTIL_FOUND, Action.WAIT_UNTIL_NOT_FOUND]
        exclude_area = True if action in wait_actions else False
        locator_phrase = State.panel.screen.get_locator(locator).get_phrase(
            vtext=vtext,
            filters=[State.function, State.color, State.family],
            exclude_area=exclude_area,
            lookup=State.panel.screen.strings
        )

        locator_action = State.panel.screen.get_locator(locator)\
            .get_action_specifier(action)
        action_phrase = State.action.get_action(action).\
            get_panelsize(State.panel_size).get_phrase(
                *args,
                preset=locator_action
            )

        step = "%s %s" % (
            locator_phrase.strip(),
            action_phrase.strip()
        )
        LOGGER.debug(step)
        State.return_value = State.ups.regex(step)

    def next(self):
        """ Return next state.
        """
        return DeterminePopupReset()

class ExecuteActionOnly(State):
    """ Execute UPS Action only.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        action_phrase = State.action.get_action(action).\
            get_panelsize(State.panel_size).get_phrase(*args)
        LOGGER.debug(action_phrase)
        State.return_value = State.ups.regex(action_phrase)

    def next(self):
        """ Return next state.
        """
        return DeterminePopupReset()

class DeterminePopupReset(State):
    """ Determine whether or not to reset the loaded_popup.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        reset = False
        if action in [Action.PRESS, Action.PRESS_KEY_COMBINATION]:
            locator_in_loaded_popup = State.panel.screen.get_locator(
                locator,
                raise_exception=False,
                popup_only=True
            )
            # reset if pressed locator is not in loaded_popup
            if locator_in_loaded_popup is None:
                reset |= True

        elif action is Action.PRESS_KEY and args[0] == "KEYCODE_HOME":
            # reset if key is "KEYCODE_HOME"
            reset |= True

        if reset:
            LOGGER.debug("Reset loaded_popup")
            State.panel.screen.loaded_popup = None # reset

    def next(self):
        """ Return next state.
        """
        return StoreNextScreen()

class StoreNextScreen(State):
    """ Store next screen to State.pending_screen. The actual traversal will
    occur ON THE NEXT NAVIGATION.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        if action in [Action.PRESS, Action.PRESS_KEY_COMBINATION] and\
           State.panel.screen.loaded_popup is None:
           if locator not in ["Log In Button"]:
               State.pending_screen = locator
        elif action is Action.PRESS_KEY and args[0] == "KEYCODE_HOME":
            State.pending_screen = "HOME"
        LOGGER.debug(State.pending_screen)

    def next(self):
        """ Return next state.
        """
        return StoreTimestamp()

class StoreTimestamp(State):
    """ Store end of navigation timestamp to State.timestamp
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        State.timestamp = time.time()

    def next(self):
        """ Return next state.
        """
        return End()

class End(State):
    """ Just an empty state.
    """

    def run(self, action, *args, locator, vtext):
        """ Execute state procedure.
        """
        pass

    def next(self):
        """ Return next state.
        """
        pass
