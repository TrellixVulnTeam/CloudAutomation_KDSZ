# Note from gilopez@lexmark.com:
# Please do not add any other step in this file.
# This file should contain only this one universal panel step.
# To spit debug: :5,$s/ #print / print /g (yeah sorry too crude for now)

# Documentation has now been moved from this file to:
# features/steps/panel/README_universal.txt
# which is also accessible via browser here:
# http://web-fwtest.lrdc.lexmark.com/tools/ftl-tools/LettuceRunner_Steps/text/README_universal.txt

# Support as Stand-alone Python Script
# This file can be lifted from the lettuce-runner and can be run as an
# independent python script. For syntax and samples, navigate to the bottom of
# this file where main() is located.

# FW-UI Automation Web Services in Different Architectures and Products
# https://twiki.lpdev.prtdev.lexmark.com/bin/view/UI/GuiAutomationWebServices

import os
import re
import cgi
import sys
import time
import json
import socket
import struct
import urllib.request, urllib.parse, urllib.error
import http.client
import hashlib
import threading
import filecmp
import html.parser
from lxml import etree
from threading import Thread
from subprocess import Popen, PIPE
from imghdr import what as image_type
from http.server import HTTPServer
from http.server import BaseHTTPRequestHandler
# try:
#     from lettuce import world
# except:
#     pass

PORT = 8090
HOST_IP = None
HTTP_OK = 200
DELAY_SEC = 0.0
# LAST_EXEC_STEP_REGEX is solely used by the function execute_step_regex
# to calculate necessary delays. This is different from other delays
# in this module.
LAST_EXEC_STEP_REGEX = 0
# Because this module exposes a function and not a class,
# LAST_WEBSERVICE_CALL_TIMESTAMP cannot be static property of NonAndroidTouchUPS.
# It is because NonAndroidTouchUPS is re-instantiated all the time.
# Hence, make it static under this module and not under NonAndroidTouchUPS.
LAST_WEBSERVICE_CALL_TIMESTAMP = 0
IP_ADDRESS = None
DEVICE_INFO = None
GLOBAL_RETVAL = None
HELP = "You are using Universal Panel Step (UPS) which is documented here:\n" \
       "http://web-fwtest.lrdc.lexmark.com/tools/ftl-tools/LettuceRunner_Steps/text/README_universal.txt\n"
# list and dictionary of recent events we want to monitor. these containers are
# reset after checking them. how to use: after a user triggered event like
# pressing a key/button, check for a viewUpdate event in this list/dict. you
# don't proceed with another feature file step until you see that event
# occurred. so you check through the list/dict endlessly until you find it (or
# give up after a fixed timeout). after that, reset these containers to empty.
RECENT_EVENTS_LIST = []
# map of event name to its occurrence count. you might prefer to use this since
# this is a compact container.
# for both of these containers, the event name contains the view name also in
# this format, event_name:view_name. view name is the name of the view that
# actually changed for that event.
RECENT_EVENTS_DICT = {}
# TODO: Create "class RecentEventData" and these 2 containers will just be
# data members with public accessor functions like:
# 1. add_event(event_name, view_name)
# 2. wait_for_event(event_name, view_name)
# 3. clear()
OS = 'linux'
##############################################################################
#
# EVENT LISTENER CLASSES
#
##############################################################################

# for non 2-line panels (android and non-android)
class WebServer:

    def __init__(self):
        pass

    def start(self):
        # create web server thread
        #print "%sRMME starting web server\n%s" % ("\033[1;33m", "\033[0m")
        t = threading.Thread(target=self.create_server, args = ((HOST_IP, PORT), PostHandler))
        t.daemon = True
        t.start()

    def create_server(self, xxx_todo_changeme, posthandler):
        # create web server
        #print "%sRMME creating web server\n%s" % ("\033[1;33m", "\033[0m")
        (hostip, port) = xxx_todo_changeme
        server = HTTPServer((hostip, int(port)), posthandler)
        server.serve_forever()

    def stop(self):
        # send QUIT request to http server running on localhost:<port>
        #print "%sRMME stopping web server\n%s" % ("\033[1;33m", "\033[0m")
        conn = http.client.HTTPConnection('{}:{}'.format(HOST_IP, PORT))
        conn.request("QUIT", "/")
        conn.getresponse()

# for 2-line panel (yep, it uses plain socket, not http server)
class SocketThread(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.setName("SocketThread")
        self.execute = True

    def run(self):
        server_name = HOST_IP
        server_port = PORT
        server_address = (server_name, server_port)

        # create a TCP/IP socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        #print "%sRMME binding socket: server_name: <%s>, server_port: <%s>\n%s" % ("\033[1;33m", server_name, server_port, "\033[0m")
        sock.bind(server_address)
        sock.listen(1)
        # fine-tune this timeout: is this too long?
        timeout_sec = 10
        sock.settimeout(timeout_sec)

        #print "%sRMME starting socket loop\n%s" % ("\033[1;33m", "\033[0m")
        while self.execute:
            #print "%sRMME waiting for a connection with <%s-sec> timeout\n%s" % ("\033[1;33m", timeout_sec, "\033[0m")
            success = True
            try:
                connection, client_address = sock.accept()
            except socket.timeout:
                success = False
                #print "%sRMME socket timed out, stopped accepting connections\n%s" % ("\033[1;33m", "\033[0m")
            if success:
                try:
                    #print "%sRMME client connected\n%s" % ("\033[1;33m", "\033[0m")
                    while self.execute:
                        # data is in json format, e.g., {"panel":{"viewUpdate":"ViewUpdated"}
                        # TODO: Add data into RECENT_EVENTS_LIST and RECENT_EVENTS_DICT
                        data = connection.recv(256)
                        #print "%sRMME received data: <%s>\n%s" % ("\033[1;33m", data, "\033[0m")
                        if data:
                            connection.sendall(data)
                        else:
                            break
                finally:
                    connection.close()
                    #print "%sRMME closed connection\n%s" % ("\033[1;33m", "\033[0m")

    def set_execute(self, execute):
        self.execute = execute
        #print "%sRMME set socket loop condition to false\n%s" % ("\033[1;33m", "\033[0m")

SOCKET_THREAD = SocketThread()
WEB_SERVER = WebServer()

# global functions for setup/teardown of event listener. for lettuce-runner,
# call these functions in terrain.py. for stand-alone, call them in main().
def start_event_listener():
    if DEVICE_INFO.is_panel_2line():
        #print "%sRMME starting SOCKET_THREAD\n%s" % ("\033[1;33m", "\033[0m")
        SOCKET_THREAD.start()
        register_events(events='viewChange')
    else:
        #print "%sRMME starting WEB_SERVER\n%s" % ("\033[1;33m", "\033[0m")
        WEB_SERVER.start()
        register_events()

def stop_event_listener():
    if DEVICE_INFO.is_panel_2line():
        #print "%sRMME stopping SOCKET_THREAD\n%s" % ("\033[1;33m", "\033[0m")
        unregister_events(events='viewChange')
        SOCKET_THREAD.set_execute(False)
        SOCKET_THREAD.join()
    else:
        #print "%sRMME stopping WEB_SERVER\n%s" % ("\033[1;33m", "\033[0m")
        unregister_events()
        WEB_SERVER.stop()

class PostHandler(BaseHTTPRequestHandler):
    # http://pymotw.com/2/BaseHTTPServer/

    # handle the Post Request from printer
    def do_POST(self):
        # Parse the form data posted
        form = cgi.FieldStorage(
            fp=self.rfile,
            headers=self.headers,
            environ={'REQUEST_METHOD':'POST',
                     'CONTENT_TYPE':self.headers['Content-Type'],
                     })

        try:
            # Begin the response
            self.send_response(HTTP_OK)
            self.end_headers()
            self.wfile.write('Client: %s\n' % str(self.client_address))
            self.wfile.write('User-agent: %s\n' % str(self.headers['user-agent']))
            self.wfile.write('Path: %s\n' % self.path)
            self.wfile.write('Form data:\n')
        except:
            pass
            #print "%sRMME response failed\n%s" % ("\033[1;33m", "\033[0m")

        # Echo back information about what was posted in the form
        #i = 0 # commented since used only in debug spit below
        for field in list(form.keys()):
            field_item = form[field]
            ##print "%sRMME i: <%s>, field: <%s>, field_item: <%s>\n%s" % ("\033[1;33m", i, field, field_item, "\033[0m")
            #i: <0>, field: <viewName>, field_item: <MiniFieldStorage('viewName', 'com.lxk.home:id/home')>
            #i: <1>, field: <time>, field_item: <MiniFieldStorage('time', '931616226')>
            #i =+ 1
            if field_item.filename:
                # The field contains an uploaded file
                file_data = field_item.file.read()
                file_len = len(file_data)
                del file_data
                self.wfile.write('\tUploaded %s as "%s" (%d bytes)\n' % \
                        (field, field_item.filename, file_len))
            else:
                # Regular form value
                self.wfile.write('\t%s=%s\n' % (field, form[field].value))

        event_name = get_regex_substr(" /(.*) ", self.requestline)
        view_name = form.getvalue('viewName') # same as form['viewName']
        if not view_name:
            view_name = "None"
        dict_key = event_name + ':' + view_name
        #print "%sRMME self.requestline: <%s>, event_name: <%s>, view_name: <%s>\n%s" % ("\033[1;33m", self.requestline, event_name, view_name, "\033[0m")
        if dict_key in RECENT_EVENTS_DICT:
            RECENT_EVENTS_DICT[dict_key] += 1
        else:
            RECENT_EVENTS_DICT[dict_key] = 1
        RECENT_EVENTS_LIST.append(dict_key)

        #print "%sRMME most recent list of events after last reset\n%s" % ("\033[1;33m", "\033[0m")
        #for event in RECENT_EVENTS_LIST:
        #    #print "%sRMME event: <%s>\n%s" % ("\033[1;33m", event, "\033[0m")

        #print "%sRMME most recent dict of events after last last reset\n%s" % ("\033[1;33m", "\033[0m")
        for key in RECENT_EVENTS_DICT:
            pass
            #print "%sRMME key: <%s>, value: <%s>\n%s" % ("\033[1;33m", key, RECENT_EVENTS_DICT[key], "\033[0m")

    # stoppable server
    def do_QUIT (self):
        # send 200 OK response, and set server.stop to True
        self.send_response(HTTP_OK)
        self.end_headers()
        self.server.stop = True

    # comment this method if you want to turn on http server log messages
    # this is overriden here so that it will not display log messages
    #def log_message(self, format, *args):
    #    return

##############################################################################
#
# UNIVERSAL PANEL STEP
#
##############################################################################

def find_widget_and_do_action(area_phrase, areanode_whereclause, \
                              text_phrase, textnode_whereclause, \
                              widget_phrase, widgetnode_whereclause, \
                              action_phrase, action):

    #print "%sRMME area_phrase: <%s>\n%s" % ("\033[1;33m", area_phrase, "\033[0m")
    #print "%sRMME areanode_whereclause: <%s>\n%s" % ("\033[1;33m", areanode_whereclause, "\033[0m")
    #print "%sRMME text_phrase: <%s>\n%s" % ("\033[1;33m", text_phrase, "\033[0m")
    #print "%sRMME textnode_whereclause: <%s>\n%s" % ("\033[1;33m", textnode_whereclause, "\033[0m")
    #print "%sRMME widget_phrase: <%s>\n%s" % ("\033[1;33m", widget_phrase, "\033[0m")
    #print "%sRMME widgetnode_whereclause: <%s>\n%s" % ("\033[1;33m", widgetnode_whereclause, "\033[0m")
    #print "%sRMME action_phrase: <%s>\n%s" % ("\033[1;33m", action_phrase, "\033[0m")
    #print "%sRMME action: <%s>\n%s" % ("\033[1;33m", action, "\033[0m")

    global IP_ADDRESS
    global DEVICE_INFO
    # try:
    #     IP_ADDRESS = world.url
    # except:
    #     # for stand-alone script IP_ADDRESS is set in main()
    #     pass

    # Instantiate this class only once
    if DEVICE_INFO is None:
        DEVICE_INFO = DeviceInfo(ip=IP_ADDRESS)
        DEVICE_INFO.initialize()

    if DEVICE_INFO.is_sim() or not DEVICE_INFO.is_panel_2line():
        # the set delays only apply to 2-line panel, otherwise unset them.
        # UI crashes and hangs happen in 2-line bec UPS is too fast.
        # we are adding a delay before every webservices call.
        global DELAY_SEC
        DELAY_SEC = 0.0
        #print "%sRMME Fast!\n%s" % ("\033[1;33m", "\033[0m")
    else:
        pass
        #print "%sRMME Slow!\n%s" % ("\033[1;33m", "\033[0m")

    if text_phrase:
        if not textnode_whereclause:
            msg = "\nOn-text phrase can't be empty.\n"
            raise ValueError(msg)
    if widget_phrase:
        if not widgetnode_whereclause:
            msg = "\nFind-widget phrase can't be empty.\n"
            raise ValueError(msg)
    else:
        if not text_phrase:
            # both on-text and find-widget phrases are not specified
            if action.startswith("press key") \
                or action.startswith("delay") \
                or action.startswith("type"):
                do_independent_action(action)
                return
            elif action.startswith("swipe"):
                # swipe action may not require either/both On-text
                # and Find-widget phrase/s.
                pass
            else:
                msg = "\nOn-text phrase and find-widget phrase " \
                      "can't both be missing.\n"
                raise ValueError(msg)

    ups = None
    if DEVICE_INFO.is_non_android_touch():
        ups = NonAndroidTouchUPS()
    elif DEVICE_INFO.is_non_android_non_touch():
        ups = NonAndroidNonTouchUPS()
    else:
        ups = AndroidUPS()

    if action.startswith("swipe"):
        # NOTE: this is a hack; the sole purpose of swipe action is nls-crawler
        if DEVICE_INFO.is_non_android_non_touch():
            msg = "\nSwipe action cannot be used for non-android-"\
                  "non-touch panels.\n"
            raise ValueError(msg)
        ups.do_swipe_action(areanode_whereclause, action)
    else:
        # normal case
        ups.find_widget_and_do_action(areanode_whereclause, \
                                    textnode_whereclause, \
                                    widgetnode_whereclause, \
                                    action)
    return GLOBAL_RETVAL

##############################################################################
#
# ANDROID UPS
#
##############################################################################

class AndroidUPS:

    def __init__(self):
        pass

    # AndroidUPS
    def find_widget_and_do_action(self, areanode_whereclause, \
                                        textnode_whereclause, \
                                        widgetnode_whereclause, \
                                        action):
        self.areanode_whereclause = areanode_whereclause
        self.textnode_whereclause = textnode_whereclause
        self.widgetnode_whereclause = widgetnode_whereclause
        self.action = action

        self.areanode_index = None
        self.swipe_offsetx = None
        self.swipe_offsety0 = None
        self.swipe_offsety1 = None
        self.force_scroll = None
        self.get_areanode_specifiers()

        self.non_existence_test = False
        if self.action == "verify none such exists":
            self.non_existence_test = True

        if self.action.startswith("wait_until_found") or \
           self.action.startswith("wait_until_not_found"):
            widgetnode = find_widget_with_wait(self.areanode_whereclause, self.action, self.find_widget)
        else:
            widgetnode = self.find_widget()

        if widgetnode is not None:
            if self.non_existence_test:
                # this only handles single match found, multiple matches found
                # should have been handled immediately prior to this point
                msg = "\nExpecting no match but a matching widget is found.\n"
                raise ValueError(msg)
            else:
                if self.action.startswith("set seekbar"):
                    self.set_seekbar(widgetnode)
                else:
                    self.do_action(widgetnode)
        else:
            if not self.non_existence_test and \
               not self.action.startswith("wait_until_not_found"):
                # this is everybody's favorite msg.
                # you will see this often while you are constructing
                # and trying out the best wording for your step.
                msg = "\nDid not find the specified widget.\n"
                raise ValueError(msg)

    # AndroidUPS
    def get_areanode_specifiers(self):
        self.areanode_index = -1
        self.swipe_offsetx = -1
        self.swipe_offsety0 = 0
        self.swipe_offsety1 = -1
        self.force_scroll = False

        if self.areanode_whereclause:
            specifier_default = "-1"
            specifier_regex = ":index=(\d+)"
            self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
            if specifier_value != specifier_default:
                # zero-based index
                self.areanode_index = int(specifier_value) - 1

            # specifier_default = "-1"
            # specifier_regex = ":swipe_offsetx=([+-]?\d+)"
            # self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
            # self.swipe_offsetx = int(specifier_value)

            specifier_default = "0"
            specifier_regex = ":swipe_offsety0=([+-]?\d+)"
            self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
            self.swipe_offsety0 = int(specifier_value)

            specifier_default = "-1"
            specifier_regex = ":swipe_offsety1=([+-]?\d+)"
            self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
            self.swipe_offsety1 = int(specifier_value)

            specifier_default = "false"
            specifier_regex = ":force_scroll=(true)"
            self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
            if specifier_value != specifier_default:
                # there is only one valid value: 'true'
                self.force_scroll = True

    # AndroidUPS
    def set_seekbar(self, node):
        min_x, y0, max_x, y1 = self.get_node_coordinates(node)
        y = (y0 + y1) / 2
        pattern = "set seekbar='([+-]?\d+)':widget='(.*)'"
        match_object = re.match(pattern, self.action)
        if match_object:
            desired_value = int(match_object.group(1))
            resource_id = match_object.group(2)
            widgetnode_whereclause = resource_id

            # note on areanode_check_done=True. this is bec find_widget() by
            # default will validate areanode_index as if it has not been
            # checked yet from user's input and convert its value to zero-based
            # index. but here it has already been. so our 2nd call to
            # find_widget() already has a correct valid value. e.g.,
            # areanode_index=0 if it were -1 (-1 is default if not specified by
            # user). so we don't want it to be checked again the 2nd time or an
            # incorrect error is raised.
            widgetnode = self.find_widget(widgetnode_whereclause, areanode_check_done=True)
            if widgetnode is not None:
                # check first if seekbar's current value
                # is already the desired value.
                current_value = int(widgetnode.attrib['text'])
                #print "%sRMME current_value: <%s>\n%s" % ("\033[1;33m", current_value, "\033[0m")
                if current_value == desired_value:
                    return
            else:
                msg = "\nSeekbar's text widget with resource-id <{}> not found.\n".format(resource_id)
                raise ValueError(msg)

            # pick the middle x-range value, press that point in the seekbar,
            # and check its resulting value if that is not the desired value,
            # we halve the range and repeat the process all over again.
            # the advantage of this method is we don't have to know the
            # seekbar's domain of values. yep, some seekbars don't specify
            # their min/max domain values in the xml. the only range we need to
            # know is the x-range of the seekbar. this method is effectively
            # just a binary search algorithm of complexity O(log(n)). in a
            # domain of 100 values (e.g. 1-100), we only need a max of 7
            # iterations log2(n+1)
            retry_count = 0
            retry_max = 10
            while (True):
                retry_count += 1
                # find the middle number of the x-range and make that our guess
                # we use (max_x + 1) to make max_x the ceiling, not (max_x - 1)
                half_length = (max_x + 1 - min_x) / 2
                mid_x = min_x + half_length
                touch_and_release(mid_x, y)
                #time.sleep(1)
                widgetnode = self.find_widget(widgetnode_whereclause, \
                                              areanode_check_done=True)
                if widgetnode is not None:
                    current_value = int(widgetnode.attrib['text'])
                    #print "%sRMME current_value: <%s>\n%s" % ("\033[1;33m", current_value, "\033[0m")
                    if current_value == desired_value:
                        #print "%sRMME retry_count: <%s>\n%s" % ("\033[1;33m", retry_count, "\033[0m")
                        break
                    #print "%sRMME min_x: <%s>, max_x: <%s>\n%s" % ("\033[1;33m", min_x, max_x, "\033[0m")
                    #print "%sRMME mid_x: <%s>\n%s" % ("\033[1;33m", mid_x, "\033[0m")
                    # on each iteration, we halve the range
                    # i.e., only keep either the upper or lower half
                    if current_value > desired_value:
                        #print "%sRMME Bad guess, choose a lower number\n%s" % ("\033[1;33m", "\033[0m")
                        max_x = mid_x # keep the lower half
                    else: # current_value < desired_value
                        #print "%sRMME Bad guess, choose a higher number\n%s" % ("\033[1;33m", "\033[0m")
                        min_x = mid_x # keep the higher half
                    if retry_count > retry_max:
                        msg = "\nSeekbar not set to desired value <{}> after <{}> retries.\n".format(desired_value, retry_max)
                        raise ValueError(msg)
                else:
                    msg = "\nSeekbar's text widget with resource-id <{}> not found.\n".format(resource_id)
                    raise ValueError(msg)
        else:
            msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
            raise ValueError(msg)

    # AndroidUPS
    def do_action(self, node):
        x, y = self.get_node_coordinates_center_point(node)
        if self.action == "nothing":
            pass
        elif self.action == "verify none such exists":
            # already processed in the calling fn
            pass
        elif self.action.startswith("wait_until_found") or self.action.startswith("wait_until_not_found"):
            # already processed in the calling fn
            pass
        elif self.action.startswith("press"):
            self.action = self.action[5:] # 6th up to last character
            offsetx = 0
            offsety = 0
            time_sec = 0 # press time for long press

            if self.action:
                specifier_default = "0"
                specifier_regex = ":offsetx=([+-]?\d+)"
                self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
                offsetx = int(specifier_value)

                specifier_default = "0"
                specifier_regex = ":offsety=([+-]?\d+)"
                self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
                offsety = int(specifier_value)

                specifier_default = "0"
                specifier_regex = ":time_sec=(\d+)"
                self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
                time_sec = int(specifier_value) # seconds

                if self.action:
                    msg = "\nPlease remove action's invalid excess string <{}>.\n".format(self.action)
                    raise ValueError(msg)

            # time specifier is in seconds. touch_and_release (swipe
            # webservice) is in milliseconds. Hence, the conversion below.
            # Also for simplicity and ease to use, press specifier
            # ":time_sec=(\d+)" is ONLY applied here.
            # Thus, all other presses have time_sec equal to zero (default).
            time_sec *= 1000
            touch_and_release(x + offsetx, y + offsety, time_sec)
        elif self.action.startswith("type"):
            pattern = "type '(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                touch_and_release(x, y)
                text = match_object.group(1)
                text = unescape_quotes(text)
                type_text(text)
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action == "clear":
            text = node.attrib['text']
            text_length = len(text)
            #print "%sRMME text: <%s>, text_length: <%s>\n%s" % ("\033[1;33m", text, text_length, "\033[0m")
            press_and_release("KEYCODE_MOVE_END")
            for i in range(0, text_length):
                press_and_release("KEYCODE_DEL")
        elif self.action.startswith("verify"):
            pattern = "verify (.*)='(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                key = match_object.group(1)
                value = match_object.group(2)
                value = unescape_quotes(value)
                value = unescape_html(value)
                attribute_dict = { key : value }
                if not is_dict1_subset_of_dict2(attribute_dict, node.attrib):
                    msg = "\nAction <{}> has been evaluated and is verified to be false.\n" \
                          "Here is the matching widget that was verified:\n\n" \
                          "{}\n\n" \
                          "If that is not the intended widget, please correct your step.\n" \
                          .format(self.action, node.attrib)
                    raise ValueError(msg)
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action.startswith("set"):
            pattern = "set (checked|selected)='(true|false)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                key = match_object.group(1)
                value = match_object.group(2)
                if key in node.attrib:
                    current_value = node.attrib[key]
                    if value != current_value:
                        touch_and_release(x, y)
                else:
                    msg = "\nAttribute <{}> does not exist in the matching widget.\n" \
                          "Here is the matching widget that was evaluated to receive the action:\n\n" \
                          "{}\n\n" \
                          "If that is not the intended widget, please correct your step.\n" \
                          .format(self.action, node.attrib)
                    raise ValueError(msg)
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action.startswith("return"):
            pattern = "return '(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                attribute_name = match_object.group(1)
                set_global_return(node.get(attribute_name))
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        else:
            msg = "\nAction <{}> is not a valid action.\n".format(self.action)
            raise ValueError(msg)

    # AndroidUPS
    def do_swipe_action(self, areanode_whereclause, action, areanode_check_done=False):
        #print("%sRMME areanode_whereclause: <%s>\n%s" % ("\033[1;33m", areanode_whereclause, "\033[0m"))
        #print("%sRMME action: <%s>\n%s" % ("\033[1;33m", action, "\033[0m"))
        self.areanode_whereclause = areanode_whereclause
        self.action = action

        # parse areanode specifiers
        self.areanode_index = None
        self.swipe_offsetx = None
        self.swipe_offsety0 = None
        self.swipe_offsety1 = None
        self.force_scroll = None
        self.get_areanode_specifiers()

        # parse action and its specifiers
        direction, count, until_edge = get_swipe_action_specifiers(self.action)

        if self.areanode_whereclause:
            is_area_boundary_reached = False
            self.areanode = download_panel_xml_into_etree_root("panel.xml")
            self.areanode_xpath_condition = None
            can_swipe, swipe_orientation = self.find_areanode(self.areanode, areanode_check_done)

            if can_swipe and count > 0:
                for cnt in range(count):
                    #print "%sRMME count: <%s>\n%s" % ("\033[1;33m", cnt, "\033[0m")
                    is_area_boundary_reached = self.full_swipe_to_next_pane(direction, swipe_orientation)
                    if is_area_boundary_reached:
                        #print "%sRMME is_area_boundary_reached: <%s>\n%s" % ("\033[1;33m", is_area_boundary_reached, "\033[0m")
                        break
            elif can_swipe and until_edge:
                while not is_area_boundary_reached:
                    is_area_boundary_reached = self.full_swipe_to_next_pane(direction, swipe_orientation)
            else:
                msg = "\nCurrent screen cannot be swiped/scrolled.\n"
                raise ValueError(msg)

        else:
            msg = "\nIn-area phrase must be used with swipe action.\n"
            raise ValueError(msg)

    # AndroidUPS
    def find_widget(self, widgetnode_whereclause=None, areanode_check_done=False):
        root = download_panel_xml_into_etree_root("panel.xml")
        self.areanode = root
        self.areanode_xpath_condition = None
        can_scroll = False
        swipe_orientation = "vertical"

        if widgetnode_whereclause is None:
            widgetnode_whereclause = self.widgetnode_whereclause
        if self.areanode_whereclause:
            can_scroll, swipe_orientation = self.find_areanode(root, areanode_check_done)

        self.textnode_xpath_condition = None
        self.widgetnode_xpath_condition = None
        if self.textnode_whereclause is None:
            self.textnode_xpath_condition = self.convert_whereclause_into_xpath_condition(widgetnode_whereclause)
        else:
            self.textnode_xpath_condition = self.convert_whereclause_into_xpath_condition(self.textnode_whereclause, "text")
        if widgetnode_whereclause is not None:
            self.widgetnode_xpath_condition = self.convert_whereclause_into_xpath_condition(widgetnode_whereclause)

        #print "%sRMME self.textnode_xpath_condition: <%s>\n%s" % ("\033[1;33m", self.textnode_xpath_condition, "\033[0m")
        #print "%sRMME self.widgetnode_xpath_condition: <%s>\n%s" % ("\033[1;33m", self.widgetnode_xpath_condition, "\033[0m")
        #print "%sRMME self.areanode.attrib: <%s>\n%s" % ("\033[1;33m", self.areanode.attrib, "\033[0m")
        #print "%sRMME can_scroll: <%s>\n%s" % ("\033[1;33m", can_scroll, "\033[0m")

        widgetnode = None
        is_area_boundary_reached = False
        swipe_direction = "forward"
        swipe_forward_count = 0
        reverse_done = False
        while widgetnode is None:
            #print "%sRMME MAIN LOOP: Swipe Next Pane Traversal ----------\n%s" % ("\033[1;33m", "\033[0m")
            #print "%sRMME self.areanode.attrib: <%s>\n%s" % ("\033[1;33m", self.areanode.attrib, "\033[0m")
            widgetnode = self.find_widgetnode()
            if widgetnode is None:
                if can_scroll:
                    #print "%sRMME is_area_boundary_reached: <%s>\n%s" % ("\033[1;33m", is_area_boundary_reached, "\033[0m")
                    if not is_area_boundary_reached:
                        if swipe_direction == "forward":
                            swipe_forward_count += 1
                            #print "%sRMME swipe_forward_count: <%s>\n%s" % ("\033[1;33m", swipe_forward_count, "\033[0m")
                        #print "%sRMME swipe_direction: <%s>\n%s" % ("\033[1;33m", swipe_direction, "\033[0m")
                        is_area_boundary_reached = self.full_swipe_to_next_pane(swipe_direction, swipe_orientation)
                    else:
                        if not reverse_done:
                            swipe_direction = "backward"
                            #print "%sRMME reversing swipe direction to backwards\n%s" % ("\033[1;33m", "\033[0m")
                            if swipe_forward_count == 1:
                                # starting pane is already at the bottom
                                is_area_boundary_reached = False
                                # False so we can swipe again in reverse
                            else:
                                # go backwards to starting pane
                                for i in range(swipe_forward_count - 1):
                                    # -1 above means don't count the last
                                    # "boundary-is-reached" zero-movement
                                    # full_swipe_to_next_pane()
                                    is_area_boundary_reached = self.full_swipe_to_next_pane(swipe_direction, swipe_orientation)
                            reverse_done = True
                        else:
                            break
                else:
                    # if can't scroll, nowhere else to look!
                    break

        return widgetnode

    # AndroidUPS
    def find_areanode(self, root, areanode_check_done):
        can_scroll = False
        swipe_orientation = "vertical"

        self.areanode_xpath_condition = self.convert_whereclause_into_xpath_condition(self.areanode_whereclause)
        areanode_xpath = ".//node[{}]".format(self.areanode_xpath_condition)
        #print "%sRMME self.areanode_xpath_condition: <%s>\n%s" % ("\033[1;33m", self.areanode_xpath_condition, "\033[0m")
        #print "%sRMME areanode_xpath: <%s>\n%s" % ("\033[1;33m", areanode_xpath, "\033[0m")
        areanodes = root.xpath(areanode_xpath)
        areanodes_count = len(areanodes)
        #print "%sRMME areanodes_count: <%s>\n%s" % ("\033[1;33m", areanodes_count, "\033[0m")

        self.areanode, self.areanode_index = \
                                get_areanode(areanodes, \
                                areanodes_count, self.areanode_index, \
                                self.areanode_whereclause, areanode_check_done)

        if self.force_scroll:
            can_scroll = True
        else:
            scrollability_dict = { "scrollable" : "true" }
            can_scroll = is_dict1_subset_of_dict2(scrollability_dict, self.areanode.attrib)

        # for now only the home screen (indicated by presence of top menu
        # bar) has horizontal swipe orientation
        topmenubar_xpath = ".//node[@resource-id='com.lxk.home:id/top_menu_bar']"
        #print "%sRMME topmenubar_xpath: <%s>\n%s" % ("\033[1;33m", topmenubar_xpath, "\033[0m")
        topmenubars = root.xpath(topmenubar_xpath)
        topmenubars_count = len(topmenubars)
        #print "%sRMME topmenubars_count: <%s>\n%s" % ("\033[1;33m", topmenubars_count, "\033[0m")
        if topmenubars_count == 1:
            swipe_orientation = "horizontal"

        return can_scroll, swipe_orientation

    # AndroidUPS
    def find_widgetnode(self):
        widgetnode = None
        textnode_xpath = ".//descendant-or-self::node[{}]".format(self.textnode_xpath_condition)
        # above prefix 'u' to literal for unicode
        #textnode_xpath = ".//descendant-or-self::node[%s]" % (self.textnode_xpath_condition)
        # above alternative: %s has no unicode issues
        #print "%sRMME textnode_xpath: <%s>\n%s" % ("\033[1;33m", textnode_xpath, "\033[0m")
        textnodes = self.areanode.xpath(textnode_xpath)
        textnodes_count = len(textnodes)
        #print "%sRMME textnodes_count: <%s>\n%s" % ("\033[1;33m", textnodes_count, "\033[0m")

        if textnodes_count > 1:
            if self.non_existence_test and not self.widgetnode_xpath_condition:
                msg = "\nExpecting no match but <{}> matching text nodes are found.\n".format(textnodes_count)
                raise ValueError(msg)
            else:
                msg = "\nMore than 1 matching text nodes found. Count = <{}>.\n".format(textnodes_count)
                raise ValueError(msg)
        elif textnodes_count == 1:
            textnode = textnodes[0]
            #print "%sRMME textnode.attrib: <%s>\n%s" % ("\033[1;33m", textnode.attrib, "\033[0m")
            if not self.widgetnode_xpath_condition:
                return textnode

            # find widget node by looking into text node's ancestry
            # starting with text node's parent all the way up to the areanode
            hierarchy_xpath = "./"
            is_areanode_reached = False
            while widgetnode is None:
                #print "%sRMME INNER LOOP: Text Node Ancestry Traversal ----------\n%s" % ("\033[1;33m", "\033[0m")
                widgetnode = self.find_widgetnode_along_textnode_ancestry(textnode, hierarchy_xpath)
                if widgetnode is not None:
                    break
                if is_areanode_reached:
                    break
                if hierarchy_xpath == "./":
                    hierarchy_xpath = "../" # first ancestor is its parent
                else:
                    hierarchy_xpath += "../" # grandparent and upwards
                # remove the trailing '/' character
                is_areanode_reached = self.is_areanode_reached_fn(textnode, hierarchy_xpath[:-1])

        return widgetnode

    # AndroidUPS
    def find_widgetnode_along_textnode_ancestry(self, textnode, hierarchy_xpath):
        widgetnode = None
        widgetnode_xpath = "{}descendant-or-self::node[{}]".format(hierarchy_xpath, self.widgetnode_xpath_condition)
        #print "%sRMME hierarchy_xpath: <%s>\n%s" % ("\033[1;33m", hierarchy_xpath, "\033[0m")
        #print "%sRMME self.widgetnode_xpath_condition: <%s>\n%s" % ("\033[1;33m", self.widgetnode_xpath_condition, "\033[0m")
        #print "%sRMME widgetnode_xpath: <%s>\n%s" % ("\033[1;33m", widgetnode_xpath, "\033[0m")
        widgetnodes = textnode.xpath(widgetnode_xpath)
        widgetnodes_count = len(widgetnodes)
        #print "%sRMME widgetnodes_count: <%s>\n%s" % ("\033[1;33m", widgetnodes_count, "\033[0m")
        if widgetnodes_count > 1:
            if self.non_existence_test:
                msg = "\nExpecting no match but <{}> matching widgets are found.\n".format(widgetnodes_count)
                raise ValueError(msg)
            else:
                msg = "\nMore than 1 matching widget nodes found. Count = <{}>.\n".format(widgetnodes_count)
                raise ValueError(msg)
        if widgetnodes_count == 1:
            widgetnode = widgetnodes[0]
            #print "%sRMME widgetnode.attrib: <%s>\n%s" % ("\033[1;33m", widgetnode.attrib, "\033[0m")
        return widgetnode

    # AndroidUPS
    def is_areanode_reached_fn(self, textnode, hierarchy_xpath):
        ancestornode = None
        is_areanode_reached = False
        #print "%sRMME hierarchy_xpath: <%s>\n%s" % ("\033[1;33m", hierarchy_xpath, "\033[0m")
        ancestornodes = textnode.xpath(hierarchy_xpath)
        ancestornodes_count = len(ancestornodes)
        #print "%sRMME ancestornodes_count: <%s>\n%s" % ("\033[1;33m", ancestornodes_count, "\033[0m")
        if ancestornodes_count == 1:
            ancestornode = ancestornodes[0]
            is_areanode_reached = compare_dictionaries(self.areanode.attrib, ancestornode.attrib)
            #print "%sRMME ancestornode.attrib: <%s>\n%s" % ("\033[1;33m", ancestornode.attrib, "\033[0m")
            #print "%sRMME is_areanode_reached: <%s>\n%s" % ("\033[1;33m", is_areanode_reached, "\033[0m")
        return is_areanode_reached

    # AndroidUPS
    def full_swipe_to_next_pane(self, swipe_direction, swipe_orientation):
        is_area_boundary_reached = False
        swipe_msec = 1000
        # 1-sec speed proves to be consistent, no erratic behavior
        x0, y0, x1, y1 = self.get_node_coordinates(self.areanode)
        # By default and in most cases, y0 works without adjustment. An
        # In Area specifier :swipe_offsety0=([+-]?\d+) allows a variable y0
        # offset in cases in which y0 needs to be adjusted.
        y0_adjusted = y0 + self.swipe_offsety0 # variable offset, default 0
        # By default and in most cases, bottom y1 does not work, so UPS will
        # use 1 pixel higher. In rare cases in which 1 pixel higher is not
        # enough, an In area specifier :swipe_offsety1=([+-]?\d+) allows a
        # variable y1 adjustment.
        y1_adjusted = y1 + self.swipe_offsety1 # variable offset, default -1
        y_length = y1_adjusted - y0_adjusted
        y_extend = 0
        if self.force_scroll:
            # for small scroll area which is not really scrollable per
            # panel.xml. this is special handling for date/time picker and
            # similar widgets. drag y to the next/prev row's middle by
            # adding/subtracting 50% more. dragging y only up to the scroll
            # area's original y won't work for small scroll area if we retain
            # a reliable swipe speed such as 1-sec (250 msec also good). don't
            # know why this deviant behavior. we would like the 250 msec swipe
            # speed bec it is also predictable. faster swipes than that yield
            # inconsistent behavior. we are adding this handling only for
            # vertical swipe since no need is seen for horizontal swipe which
            # is used only for home swiping.
            y_extend = y_length * 0.50
            swipe_msec = 250
        x_adjusted = x1 + self.swipe_offsetx
        # self.swipe_offsetx default value is -1. that means we start from
        # rightmost x1-1 (not rightmost x1 since that may be the blue thin
        # line scrollbar)
        if self.swipe_offsetx >= 0:
            x_adjusted = x0 + self.swipe_offsetx
        #print "%sRMME x0: <%s>, y0: <%s>, x1: <%s>, y1: <%s>\n%s" % ("\033[1;33m", x0, y0, x1, y1, "\033[0m")
        #print "%sRMME self.swipe_offsetx: <%s>, x_adjusted: <%s>\n%s" % ("\033[1;33m", self.swipe_offsetx, x_adjusted, "\033[0m")
        #print "%sRMME self.swipe_offsety0: <%s>, y0_adjusted: <%s>\n%s" % ("\033[1;33m",self.swipe_offsety0, y0_adjusted, "\033[0m")
        #print "%sRMME self.swipe_offsety1: <%s>, y1_adjusted: <%s>\n%s" % ("\033[1;33m",self.swipe_offsety1, y1_adjusted, "\033[0m")
        #print "%sRMME y_length: <%s>, y_extend: <%s>\n%s" % ("\033[1;33m", y_length, y_extend, "\033[0m")

        #  NOTE:
        #    1.) `OOO` - Keypad button/icon for MM
        #    2.) For horizontal orientation, use y0_adjusted and (y0_adjusted + 1)
        #        to slightly skew or tilt the swipe direction. Otherwise,
        #        UI webservice automation will not respond in certain panel sizes.
        #    3.) For horizontal orientation, use y0_adjusted instead of y1_adjusted
        #        because the latter overlaps with `OOO`.
        if swipe_direction == "forward":
            if swipe_orientation == "vertical":
                y0_adjusted = y0_adjusted - y_extend
                swipe(x_adjusted, x_adjusted, y1_adjusted, y0_adjusted, swipe_msec)
            else:
                swipe(x1, x0, y0_adjusted, y0_adjusted + 1, swipe_msec)
                #                   H. FORWARD
                #
                #   (x0, y0_adjusted)            (x1, y0_adjusted + 1)
                # <---------------------------------------|
                #            (screen top)                 |
                #                                         |
                #                                         |
                #                                         |
                #            (screen bottom)              |
                #   OOO                                   |
                #
        else:
            if swipe_orientation == "vertical":
                y1_adjusted = y1_adjusted + y_extend
                swipe(x_adjusted, x_adjusted, y0_adjusted, y1_adjusted, swipe_msec)
            else:
                swipe(x0, x1, y0_adjusted, y0_adjusted + 1, swipe_msec)
                #
                #                   H. BACKWARD
                #
                #   (x0, y0_adjusted)            (x1, y0_adjusted + 1)
                # |--------------------------------------->
                # |          (screen top)
                # |
                # |
                # |
                # |          (screen bottom)
                # | OOO
                #

        root = download_panel_xml_into_etree_root("new_panel.xml")
        areanode_xpath = ".//node[{}]".format(self.areanode_xpath_condition)
        #print "%sRMME self.areanode_xpath_condition: <%s>\n%s" % ("\033[1;33m", self.areanode_xpath_condition, "\033[0m")
        #print "%sRMME areanode_xpath: <%s>\n%s" % ("\033[1;33m", areanode_xpath, "\033[0m")
        areanodes = root.xpath(areanode_xpath)
        self.areanode = areanodes[self.areanode_index]
        is_area_boundary_reached = self.compare_two_files_if_identical("panel.xml", "new_panel.xml", swipe_orientation)
        os.remove('panel.xml')
        os.rename('new_panel.xml', 'panel.xml')
        return is_area_boundary_reached

    # AndroidUPS
    def convert_whereclause_into_xpath_condition(self, whereclause, attribute_type=None):
        # Example:
        # whereclause = "attrib1='value1'&&attrib2='value2'"
        # xpath_condition = "@attrib1='value1' and @attrib2='value2'"

        try:
            line_feed = '\n'
            html_line_feed = '&#10;'
            whereclause = whereclause.replace(line_feed, html_line_feed)
            whereclause=whereclause.replace(' && ', '&&')
        except:
            pass

        xpath_condition = ""
        if '=' not in whereclause:
            if attribute_type is not None:
                xpath_condition = "@" + attribute_type + "='" + whereclause + "'"
            else:
                # for case insensitive
                # can't use lower-case() fn since that is XPath 2.0. lxml
                # uses XPath 1.0
                #xpath_condition = "contains(lower-case(@class), '" \
                #                  + whereclause.lower() + "')"
                # below works but not used since may potentially be slower
                # (although no slowness was observed)
                #xpath_condition = "contains(translate(@class, \
                #                            'ABCDEFGHIJKLMNOPQRSTUVWXYZ', \
                #                            'abcdefghijklmnopqrstuvwxyz'), '" \
                #                            + whereclause.lower() + "')"
                if '/' in whereclause:
                    xpath_condition = "@resource-id='" + whereclause + "'"
                else:
                    xpath_condition = "contains(@class, '" + whereclause + "')"
        else:
            # split the multiple conditions
            conditions = whereclause.split('&&')
            conditions_count = len(conditions)

            for i in range(conditions_count):
                condition = conditions[i]
                pattern = "(.*)='(.*)'"
                match_object = re.match(pattern, condition)
                if match_object:
                    quote_correct_condition = get_quote_correct_condition(condition)
                    xpath_condition += "@" + quote_correct_condition
                    if i < (conditions_count - 1):
                        xpath_condition += " and "
                else:
                    msg = "\nCondition <{}> does not follow the regex pattern <{}>.\n".format(condition, pattern)
                    raise ValueError(msg)

        return unescape_html(xpath_condition)

    # AndroidUPS
    def get_node_coordinates(self, node):
        x0, y0, x1, y1 = [_f for _f in re.split("\[|\]|,", node.attrib['bounds']) if _f]
        return int(x0), int(y0), int(x1), int(y1)

    # AndroidUPS
    def get_node_coordinates_center_point(self, node):
        x0, y0, x1, y1 = self.get_node_coordinates(node)
        x = (x0 + x1) / 2
        y = (y0 + y1) / 2
        return x, y

    # AndroidUPS
    def compare_two_files_if_identical(self, file1, file2, swipe_orientation):
        returncode = -1
        if swipe_orientation == "horizontal":
            # create panel.xml files without the top menu bar node
            # this is the node that frequently changes every second or so
            # so we want it to be removed first before doing a file comparison
            outputfile1 = "panel.xml.tmp"
            outputfile2 = "new_panel.xml.tmp"
            self.create_panel_xml_without_topmenubar_node(file1, outputfile1)
            self.create_panel_xml_without_topmenubar_node(file2, outputfile2)
            returncode = filecmp.cmp(outputfile1, outputfile2)
            os.remove(outputfile1)
            os.remove(outputfile2)
        else:
            returncode = filecmp.cmp(file1, file2)
        return returncode

    # AndroidUPS
    def create_panel_xml_without_topmenubar_node(self, filepath, outputfile):
        root = get_tree_root_from_file(filepath)
        areanode_xpath_condition = "@resource-id='com.lxk.home:id/top_menu_bar'"
        areanode_xpath = ".//node[{}]".format(areanode_xpath_condition)
        #print "%sRMME areanode_xpath_condition: <%s>\n%s" % ("\033[1;33m", areanode_xpath_condition, "\033[0m")
        #print "%sRMME areanode_xpath: <%s>\n%s" % ("\033[1;33m", areanode_xpath, "\033[0m")
        areanodes = root.xpath(areanode_xpath)
        areanode = areanodes[0]
        areanode.getparent().remove(areanode)
        file_str = etree.tostring(root, pretty_print=True, xml_declaration=True)
        file_str = file_str.decode("utf-8") if type(file_str) is bytes else file_str
        with open(outputfile, "w") as file:
            file.write(file_str)

##############################################################################
#
# NON-ANDROID NON-TOUCH UPS
#
##############################################################################

class NonAndroidNonTouchUPS:

    def __init__(self):
        pass

    # NonAndroidNonTouchUPS
    def find_widget_and_do_action(self, areanode_whereclause, \
                                        textnode_whereclause, \
                                        widgetnode_whereclause, \
                                        action):
        self.areanode_whereclause = areanode_whereclause
        self.textnode_whereclause = textnode_whereclause
        self.widgetnode_whereclause = widgetnode_whereclause
        self.action = action

        if self.action.startswith("wait_until_found") or \
           self.action.startswith("wait_until_not_found"):
            find_widget_with_wait(self.areanode_whereclause, self.action, self.find_widget)
        else:
            self.find_widget()
        self.do_action()

    # NonAndroidNonTouchUPS
    def set_areanode(self, check_done=False):
        self.root = download_panel_xml_into_etree_root("panel.xml")
        self.areanode = self.root
        self.areanode_xpath = None

        if self.areanode_whereclause:
            if not check_done:
                self.areanode_index = -1
                specifier_default = "-1"
                specifier_regex = ":index=(\d+)"
                self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
                if specifier_value != "-1":
                    # zero-based index
                    self.areanode_index = int(specifier_value) - 1

            self.areanode_xpath = ".//{}".format(self.areanode_whereclause)
            areanodes = self.root.xpath(self.areanode_xpath)
            areanodes_count = len(areanodes)

            self.areanode, self.areanode_index = get_areanode(areanodes, areanodes_count, self.areanode_index, self.areanode_whereclause, check_done)

    # NonAndroidNonTouchUPS
    def set_widgetnode_xpath(self):
        textnode_xpath_condition = ""
        widgetnode_xpath_condition = ""
        if self.textnode_whereclause is not None:
            textnode_xpath_condition = convert_whereclause_into_xpath_condition(self.textnode_whereclause, "text")
        if self.widgetnode_whereclause is not None:
            widgetnode_xpath_condition = convert_whereclause_into_xpath_condition(self.widgetnode_whereclause)
        widgetnode_xpath = textnode_xpath_condition + widgetnode_xpath_condition
        self.widgetnode_xpath = ".//descendant-or-self::*{}".format(widgetnode_xpath)

    # NonAndroidNonTouchUPS
    def find_widget(self):
        self.set_areanode()
        self.set_widgetnode_xpath()

        all_itemsnode_xpath = ".//items"
        #print "%sRMME all_itemsnode_xpath: <%s>\n%s" % ("\033[1;33m", all_itemsnode_xpath, "\033[0m")

        all_itemsnodes = self.areanode.xpath(all_itemsnode_xpath)
        self.all_itemsnodes_count = len(all_itemsnodes)
        #print "%sRMME self.all_itemsnodes_count: <%s>\n%s" % ("\033[1;33m", self.all_itemsnodes_count, "\033[0m")

        self.itemsnodes = self.areanode.xpath(self.widgetnode_xpath)
        self.itemsnodes_count = len(self.itemsnodes)
        #print "%sRMME self.itemsnodes_count: <%s>\n%s" % ("\033[1;33m", self.itemsnodes_count, "\033[0m")

        # NOTE: return value is only used by find_widget_with_wait() to support
        # wait_until_found and wait_until_not_found, and is not used in this class.
        return (None if self.itemsnodes_count == 0 else self.itemsnodes)

    # NonAndroidNonTouchUPS
    def do_action(self):
        if not self.action.startswith("verify count") and \
           not self.action.startswith("wait_until_found") and \
           not self.action.startswith("wait_until_not_found"):
            if self.itemsnodes_count == 0:
                msg = "\nDid not find the specified widget.\n"
                raise ValueError(msg)
            elif self.itemsnodes_count > 1:
                msg = "\nMore than 1 matching widget nodes found. Count = <{}>.\n".format(self.itemsnodes_count)
                raise ValueError(msg)
            #else: # self.itemsnodes_count == 1:
            #    itemsnode = self.itemsnodes[0]

        if self.action.startswith('v-select') or self.action.startswith('h-select'):
            select_orientation = self.action[:8] # first 8 characters
            self.action = self.action[8:] # 9th up to last character
            option_count = -1
            data_type = 'str'
            menu_entry = True
            attribute_name = 'selected'
            attribute_value = 'true'

            if self.action:
                specifier_default = "-1"
                specifier_regex = ":option_count=(\d+)"
                self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
                option_count = int(specifier_value)

                specifier_default = "str"
                specifier_regex = ":data_type=(int)"
                self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
                data_type = specifier_value

                specifier_default = "true"
                specifier_regex = ":menu_entry=(false)"
                self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
                if specifier_value != specifier_default:
                    menu_entry = False

                specifier_default = "none"
                specifier_regex = ":set (.*)='(.*)'"
                self.action, specifier_value1, specifier_value2 = get_specifier_attribute_and_value(self.action, specifier_default, specifier_regex)
                if specifier_value1 != specifier_default:
                    if specifier_value1 == attribute_name and specifier_value2 == attribute_value:
                        msg = "\nPlease remove action specifier <:set selected='true'> since that is the default behavior.\n"
                        raise ValueError(msg)
                    else:
                        attribute_name = specifier_value1
                        attribute_value = specifier_value2
                        attribute_value = unescape_quotes(attribute_value)

                if self.action:
                    msg = "\nPlease remove action's invalid excess string <{}>.\n".format(self.action)
                    raise ValueError(msg)

            if option_count != -1:
                    if data_type == 'int':
                        msg = "\nAction specifiers <option_count> and <data_type> can't both be present.\n"
                        raise ValueError(msg)
                    else:
                        self.select_from_unitemized_list(option_count, select_orientation, menu_entry, attribute_name, attribute_value)
            elif data_type == 'int':
                pattern = "[+-]?\d+"
                match_object = re.match(pattern, attribute_value)
                if match_object:
                    attribute_value = float(attribute_value)
                    self.select_from_integer_list(select_orientation, menu_entry, attribute_name, attribute_value)
                else:
                    msg = "\nPlease add an action specifier <:set attrib='value'> where value is an integer.\n"
                    raise ValueError(msg)
            else:
                self.select_from_itemized_list(select_orientation, menu_entry, attribute_name, attribute_value)
        elif self.action.startswith("verify count"):
            pattern = "verify count=(\d+)"
            match_object = re.match(pattern, self.action)
            if match_object:
                expected_count = int(match_object.group(1))
                if self.itemsnodes_count != expected_count:
                    msg = "\nMatching widgets count <{}> is not equal to expected count <{}>.\n" \
                          .format(self.itemsnodes_count, expected_count)
                    raise ValueError(msg)
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action.startswith("verify"):
            pattern = "verify (.*)='(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                attribute_name = match_object.group(1)
                attribute_value = match_object.group(2)
                attribute_value = unescape_quotes(attribute_value)
                attribute_value = unescape_html(attribute_value)
                curr_attribute_value = self.get_widget_attribute_value(attribute_name)
                if curr_attribute_value != attribute_value:
                    msg = "\nAttribute name <{}> current value <{}> is not equal to expected value <{}>.\n" \
                          .format(attribute_name, curr_attribute_value, attribute_value)
                    raise ValueError(msg)
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action.startswith("type"):
            pattern = "type '(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                text = match_object.group(1)
                text = unescape_quotes(text)
                textInput = None
                if DEVICE_INFO.is_panel_2line() and not DEVICE_INFO.is_mfp():
                    textInput = TextInputUsingSingleKey(text)
                else:
                    textInput = TextInputUsingNumpad(text)
                textInput = TextInputUsingNumpad(text)
                textInput.type_text()
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action.startswith("wait_until_found") or self.action.startswith("wait_until_not_found"):
            # already processed in the calling fn
            pass
        elif self.action == "clear":
            # to be updated when our new device settings class is done
            attribute_name = "text"
            text = self.get_widget_attribute_value(attribute_name)
            text_length = len(text)
            #print "%sRMME text: <%s>, text_length: <%s>\n%s" % ("\033[1;33m", text, text_length, "\033[0m")
            # cursor already at the end of text
            for i in range(0, text_length):
                press_and_release("KEY_Left")
            #press_and_release("KEY_Backspace")
            # Pressing backspace once will erase the entire contents
            # TODO: Add per character deletion support only if needed.
            # For now this is not needed since you don't type to edit and then
            # delete some characters. The case is always: you enter an input
            # field, delete all its text and then type the desired string.
        elif self.action.startswith("return"):
            pattern = "return '(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                attribute_name = match_object.group(1)
                set_global_return(self.get_widget_attribute_value(attribute_name))
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        else:
            msg = "\nAction <{}> is not valid.\n".format(self.action)
            raise ValueError(msg)

    # NonAndroidNonTouchUPS
    def get_widget_attribute_value(self, attribute_name):
        curr_attribute_value = None
        attribute_xpath = "{}/{}/text()".format(self.widgetnode_xpath, attribute_name)
        nodes = self.areanode.xpath(attribute_xpath)
        nodes_count = len(nodes)
        #print "%sRMME nodes_count: <%s>\n%s" % ("\033[1;33m", nodes_count, "\033[0m")
        # widget located at self.node_xpath is also guaranteed
        # to exist bec of prior checking so the only thing to check here is the
        # existence of the given attribute
        if nodes_count == 0:
            msg = "\nAttribute name <{}> does not exist.\n".format(attribute_name)
            raise ValueError(msg)
        curr_attribute_value = nodes[0]
        return curr_attribute_value

    # NonAndroidNonTouchUPS
    def select_from_itemized_list(self, select_orientation, menu_entry, attribute_name, attribute_value):
        # use forward/backward keys to navigate to the desired value in a list
        # here the list size is known from the actual itemized list given so we
        # know how much to navigate forward. yes, this only navigates forward.
        # therefore the list is assumed to rollover once the bottom is reached
        # i haven't seen an itemized list that doesn't rollover yet
        # so how do you support an itemized list that doesn't rollover (2 ways):
        # 1. Workaround
        #    just count the items (n) and add specifier ":option_count=n"
        #    this simply invokes select_from_unitemized_list(). no code change
        #    needed.
        # 2. Code Change
        #    just set option_count=self.all_itemsnodes_count and call
        #    select_from_unitemized_list(). you'll have to introduce a new
        #    specifier like ":rollover=false" to capture this case. now the
        #    user will thank you since he doesn't have to count the list items
        is_desired_attribute_value_set = False
        forward_key, backward_key = self.get_forward_backward_keys(select_orientation)
        hard_key = forward_key

        i = 1
        while (i <= self.all_itemsnodes_count):
            curr_attribute_value = self.get_widget_attribute_value(attribute_name)
            #print "%sRMME Attribute name <%s> current value is <%s>.\n%s" % ("\033[1;33m", attribute_name, curr_attribute_value, "\033[0m")
            if curr_attribute_value == attribute_value:
                is_desired_attribute_value_set = True
                break
            if i <= (self.all_itemsnodes_count - 1):
                # press only up to (itemcount-1) times,
                # i.e., don't rollover highlight back to original item
                press_and_release(hard_key)
                #print "%sRMME Key <%s> pressed on iteration <%s>.\n%s" % ("\033[1;33m", hard_key, i, "\033[0m")
                self.set_areanode(check_done=True)
            i += 1

        if is_desired_attribute_value_set:
            if menu_entry:
                press_and_release("KEY_Enter")
        else:
            msg = "\nAttribute name <{}> still not set to value <{}> after key <{}> was pressed <{}> times.\n" \
                  .format(attribute_name, attribute_value, hard_key, self.all_itemsnodes_count-1)
            raise ValueError(msg)

    # NonAndroidNonTouchUPS
    def select_from_integer_list(self, select_orientation, menu_entry, attribute_name, attribute_value):
        # use forward/backward keys to navigate to the desired integer value
        # here there is really no itemized integer list. we just know that the
        # integer value increments on forward key press and decrements the
        # other way. the integer values don't even need to be continuous and
        # may skip some values. an error is raised if a key press does not
        # result to a value change
        is_desired_attribute_value_set = False
        forward_key, backward_key = self.get_forward_backward_keys(select_orientation, is_numeric=True)
        hard_key = forward_key
        forward_key_press_count = 0
        backward_key_press_count = 0
        increment_needed = True
        prev_attribute_value = None

        i = 1
        while (True):
            curr_attribute_value = self.get_widget_attribute_value(attribute_name)
            pattern = "[+-]?\d+"
            match_object = re.match(pattern, curr_attribute_value)
            if match_object:
                curr_attribute_value = float(curr_attribute_value)
            else:
                msg = "\nAttribute name <{}> current value <{}> does not follow the regex pattern <{}>.\n" \
                      .format(attribute_name, curr_attribute_value, pattern)
                raise ValueError(msg)
            #print "%sRMME Attribute name <%s> current value is <%s>\n%s" % ("\033[1;33m", attribute_name, curr_attribute_value, "\033[0m")
            if curr_attribute_value == attribute_value:
                is_desired_attribute_value_set = True
                break
            elif curr_attribute_value > attribute_value:
                increment_needed = False
            if i > 1 and prev_attribute_value == curr_attribute_value:
                msg = "\nKey <{}> did not change the attribute value on its last press.\n".format(hard_key)
                raise ValueError(msg)

            if increment_needed:
                hard_key = forward_key
                forward_key_press_count += 1
            else:
                hard_key = backward_key
                backward_key_press_count += 1
            press_and_release(hard_key)
            #print "%sRMME Key <%s> pressed on iteration <%s>.\n%s" % ("\033[1;33m", hard_key, i, "\033[0m")
            self.set_areanode(check_done=True)
            prev_attribute_value = curr_attribute_value
            i += 1

        if is_desired_attribute_value_set:
            if menu_entry:
                press_and_release("KEY_Enter")
        else:
            msg = "\nAttribute name <{}> still not set to value <{}> after\n" \
                  "forward key <{}> was pressed <{}> times and\n" \
                  "backward key <{}> was pressed <{}> times.\n" \
                  .format(attribute_name, attribute_value, \
                          forward_key, forward_key_press_count, \
                          backward_key, backward_key_press_count)
            raise ValueError(msg)

    # NonAndroidNonTouchUPS
    def select_from_unitemized_list(self, option_count, select_orientation, menu_entry, attribute_name, attribute_value):
        # use forward/backward keys to navigate to the desired value
        # here there is really no list at all but the total number of navigable
        # options is known. we use that total number (n) to navigate n-1 times
        # forward then n-1 times backward until the desired value is set
        # a sample usage is that of selecting Yes/No button when there are
        # 2 options (n=2). Yes and No buttons are separate widgets (not
        # together in a list). but you can press (n-1) times the forward key
        # then (n-1) times the backward key until desired button is selected
        is_desired_attribute_value_set = False
        forward_key, backward_key = self.get_forward_backward_keys(select_orientation)
        hard_key = forward_key
        one_direction_keypress_count = option_count - 1
        # -1 above bec current selection does not need key movement
        both_direction_keypress_count = one_direction_keypress_count * 2

        i = 1
        while (i <= (both_direction_keypress_count + 1)):
            # +1 so we can evaluate the result of last iteration's key press
            curr_attribute_value = self.get_widget_attribute_value(attribute_name)
            #print "%sRMME Attribute name <%s> current value is <%s>.\n%s" % ("\033[1;33m", attribute_name, curr_attribute_value, "\033[0m")
            if curr_attribute_value == attribute_value:
                is_desired_attribute_value_set = True
                break
            if i <= both_direction_keypress_count:
                press_and_release(hard_key)
                #print "%sRMME Key <%s> pressed on iteration <%s>.\n%s" % ("\033[1;33m", hard_key, i, "\033[0m")
                self.set_areanode(check_done=True)
                if i == one_direction_keypress_count:
                    # at halfway, we reverse direction
                    hard_key = backward_key
            i += 1

        if is_desired_attribute_value_set:
            if menu_entry:
                press_and_release("KEY_Enter")
        else:
            msg = "\nAttribute name <{}> still not set to value <{}> after both\n" \
                  "forward key <{}> and then backward key <{}>\n" \
                  "were each pressed <{}> times.\n" \
                  .format(attribute_name, attribute_value, \
                          forward_key, backward_key, \
                          one_direction_keypress_count)
            raise ValueError(msg)

    # NonAndroidNonTouchUPS
    def get_forward_backward_keys(self, select_orientation, is_numeric=False):
        forward_key = "KEY_Down"
        backward_key = "KEY_Up"
        if is_numeric:
            forward_key = "KEY_Up"
            backward_key = "KEY_Down"
        if select_orientation == "h-select":
            forward_key = "KEY_Right"
            backward_key = "KEY_Left"
        return forward_key, backward_key

class TextInputUsingNumpad():
    KEY_0 = [ "0" ]
    KEY_1 = [ "1", ".", ",", "@", "!", "?", "_",
              "-", ":", ";", "#", "$", "%", "&",
              "*", "+", "=", "'", "\"", " ","(",
              ")", "[", "]", "{", "}", "/", "|",
              "\\", "<", ">", "`", "~", "^"
            ]
    KEY_2 = [ "2", "a", "b", "c", "A", "B", "C" ]
    KEY_3 = [ "3", "d", "e", "f", "D", "E", "F" ]
    KEY_4 = [ "4", "g", "h", "i", "G", "H", "I" ]
    KEY_5 = [ "5", "j", "k", "l", "J", "K", "L" ]
    KEY_6 = [ "6", "m", "n", "o", "M", "N", "O" ]
    KEY_7 = [ "7", "p", "q", "r", "s", "P", "Q", "R", "S" ]
    KEY_8 = [ "8", "t", "u", "v", "T", "U", "V" ]
    KEY_9 = [ "9", "w", "x", "y", "z", "W", "X", "Y", "Z" ]

    # TextInputUsingNumpad
    def __init__(self, text):
        self.text = text

    # TextInputUsingNumpad
    def type_text(self):
        #print "%sRMME self.text: <%s>\n%s" % ("\033[1;33m", self.text, "\033[0m")
        for char in self.text:
            #print "%sRMME char: <%s>\n%s" % ("\033[1;33m", char, "\033[0m")
            self.type_char(char)

    # TextInputUsingNumpad
    def type_char(self, char):
        # type one character using a numeric keypad by hitting the correct key
        # one or multiple times to reach the character's indexed location
        i = 0
        while i < 10:
            char_list_name = "KEY_" + str(i)
            if char in getattr(TextInputUsingNumpad, char_list_name):
                #print "%sRMME char_list_name: <%s>\n%s" % ("\033[1;33m", char_list_name, "\033[0m")
                break
            i += 1

        char_list = getattr(TextInputUsingNumpad, char_list_name)
        index = char_list.index(char)
        #print "%sRMME index: <%s>\n%s" % ("\033[1;33m", index, "\033[0m")

        url = "http://{}/webservices/automation/request/pressAndReleaseKey?key={}".format(IP_ADDRESS, char_list_name)
        i = 0
        handle = None
        while (i <= index):
            handle = urllib.request.urlopen(url)
            delay()
            i += 1
        handle.close()

        # for words with consecutive letters belonging to the same key
        # we can't simply type the 2nd letter without an intentional pause
        # to release the key and nail that first letter.
        # to do a pause we can either sleep or wait for viewUpdated.
        # but a faster hack to release the key is by pressing an alternate
        # distracting key such as an arrow key (remember the nokia days?)
        press_and_release("KEY_Up")

class TextInputUsingSingleKey():
    KEYS = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
             "A", "a", "B", "b", "C", "c", "D", "d", "E", "e",
             "F", "f", "G", "g", "H", "h", "I", "i", "J", "j",
             "K", "k", "L", "l", "M", "m", "N", "n", "O", "o",
             "P", "p", "Q", "q", "R", "r", "S", "s", "T", "t",
             "U", "u", "V", "v", "W", "w", "X", "x", "Y", "y",
             "Z", "z", ".", ",", "@", "!", "?", "_", "-", ":",
             ";", "#", "$", "%", "&", "*", "+", "=", "'", "\"",
             " ","(", ")", "[", "]", "{", "}", "/", "|", "\\"
           ]

    # TextInputUsingSingleKey
    def __init__(self, text):
        self.text = text

    # TextInputUsingSingleKey
    def type_text(self):
        #print "%sRMME self.text: <%s>\n%s" % ("\033[1;33m", self.text, "\033[0m")
        for char in self.text:
            #print "%sRMME char: <%s>\n%s" % ("\033[1;33m", char, "\033[0m")
            self.type_char(char)

    # TextInputUsingSingleKey
    def type_char(self, char):
        # type one character using only Right key
        # one or multiple times to reach the character's indexed location

        char_list = getattr(TextInputUsingSingleKey, "KEYS")
        index = char_list.index(char)
        #print "%sRMME index: <%s>\n%s" % ("\033[1;33m", index, "\033[0m")

        url = "http://{}/webservices/automation/request/pressAndReleaseKey?key=KEY_Right".format(IP_ADDRESS)
        i = 0
        handle = None
        while (i <= index):
            handle = urllib.request.urlopen(url)
            delay()
            i += 1
        handle.close()

        # nail this letter in place in preparation for next letter or finish
        press_and_release("KEY_Enter")

##############################################################################
#
# NON-ANDROID TOUCH UPS
#
##############################################################################

class NonAndroidTouchUPS:

    def __init__(self):
        pass

    # NonAndroidTouchUPS
    def find_widget_and_do_action(self, areanode_whereclause, \
                                        textnode_whereclause, \
                                        widgetnode_whereclause, \
                                        action):
        self.areanode_whereclause = areanode_whereclause
        self.textnode_whereclause = textnode_whereclause
        self.widgetnode_whereclause = widgetnode_whereclause
        self.action = action

        self.convert_step()
        self.initialize()
        if self.action.startswith("wait_until_found") or \
           self.action.startswith("wait_until_not_found"):
            find_widget_with_wait(self.areanode_whereclause, self.action, self.find_widget)
        else:
            self.find_widget()
        self.do_action()

    # NonAndroidTouchUPS
    def convert_step(self):
        # for converting 2.4" and 2-line Settings menu steps to 2.8".
        # Settings menu steps are straightforward and use these 2 constructs:
        # 1. In area "list" On text "English" Do "v-select" (or h-select)
        #    will be converted to:
        #    On text "English" Do "press"
        # 2. In area "list" On text "English" Do "verify selected='true'"
        #    will be converted to:
        #    On text "English" Do "verify selected='true'"
        if self.areanode_whereclause == "list" and \
           self.textnode_whereclause is not None and \
           self.widgetnode_whereclause is None:
            self.areanode_whereclause = ""
            if self.action == "v-select" or \
               self.action == "h-select":
                self.action = "press"
            elif self.action.startswith("verify"):
                # retain this action
                pass
            else:
                msg = "\nUnsupported construct for step conversion.\n"
                raise ValueError(msg)

    # NonAndroidTouchUPS
    def initialize(self):
        self.areanode_ascend_xpath = ""
        # MIN_DELAY_BETWEEN_WEBSERVICE_CALLS_SEC constant delay is only applied for
        # builds after 2.8" Swipe Integration. Based on UI Dev's testing,
        # delay is required between swipes. However, it has been observed
        # that delay is also required between presses.
        self.MIN_DELAY_BETWEEN_WEBSERVICE_CALLS_SEC = 0.5

    # NonAndroidTouchUPS
    def set_areanode(self, check_done=False):
        self.root = download_panel_xml_into_etree_root("panel.xml")
        self.areanode = self.root
        self.areanode_attrib = self.get_node_attrib(self.areanode)

        if self.areanode_whereclause:
            if not check_done:
                self.areanode_index = -1
                specifier_default = "-1"
                specifier_regex = ":index=(\d+)"
                self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
                if specifier_value != "-1":
                    # zero-based index
                    self.areanode_index = int(specifier_value) - 1

                areanode_ascend = -1
                specifier_default = "-1"
                specifier_regex = ":ascend=(\d+)"
                self.areanode_whereclause, specifier_value = get_specifier_value(self.areanode_whereclause, specifier_default, specifier_regex)
                if specifier_value != "-1":
                    areanode_ascend = int(specifier_value)
                    ascend_xpath = "./"
                    for i in range(0, areanode_ascend):
                        if ascend_xpath == "./":
                            ascend_xpath = "../"
                        else:
                            ascend_xpath += "../"
                    # remove the trailing '/' character
                    self.areanode_ascend_xpath = ascend_xpath[:-1]

            self.areanode_xpath = convert_whereclause_into_xpath_condition(self.areanode_whereclause)
            self.areanode_xpath = ".//object{}".format(self.areanode_xpath)
            #print "%sRMME self.areanode_xpath: <%s>\n%s" % ("\033[1;33m", self.areanode_xpath, "\033[0m")
            areanodes = self.root.xpath(self.areanode_xpath)
            areanodes_count = len(areanodes)

            self.areanode, self.areanode_index = get_areanode(areanodes, areanodes_count, self.areanode_index, self.areanode_whereclause, check_done)
            if self.areanode_ascend_xpath:
                areanodes = self.areanode.xpath(self.areanode_ascend_xpath)
                areanodes_count = len(areanodes)
                if areanodes_count == 1:
                    self.areanode = areanodes[0]
            self.areanode_attrib = self.get_node_attrib(self.areanode)
            #print "%sRMME self.areanode_attrib: <%s>\n%s" % ("\033[1;33m", self.areanode_attrib, "\033[0m")

    # NonAndroidTouchUPS
    def set_scroll_or_swipe(self):
        self.has_scrollnodes = False
        self.can_swipe = False
        if not self.areanode_ascend_xpath and\
           not self.action.startswith("wait_until_found") and\
           not self.action.startswith("wait_until_not_found"):
            # enable scroll only when there is no :ascend specifier.
            # specifying an :ascend specifier will disable scrolling even if
            # scrollers are present. this is bec :ascend is used for rare cases
            # where we use a text local to a specific pane to identify an area.
            # normally we don't do that. in other panel sizes an area phrase is
            # usually a node that is ever existing across all panes like a
            # scroll area, and not a pane-specific node.
            #
            # additionally, scrolling and swiping is disabled for conditional
            # delays. this is a workaround for design flaw that the user
            # IS NOT IN FULL CONTROL of UPS 2.8 in terms of swiping. See below
            # the conditions to enable swipe.
            self.scrollupnode = self.get_node_by_attribute("name", "scrollUp", expected_count=None)
            self.scrolldownnode = self.get_node_by_attribute("name", "scrollDown", expected_count=None)
            if self.scrollupnode is not None or self.scrolldownnode is not None:
                self.has_scrollnodes = True
                self.scrollupnode_coordinates = self.get_node_coordinates(self.scrollupnode)
                self.scrolldownnode_coordinates = self.get_node_coordinates(self.scrolldownnode)
            # only enable swipe if both scroll buttons do not exist in panel xml
            else:
                if self.get_node_by_attribute("type", "ListWidget", expected_count=None) is not None or\
                   self.areanode_whereclause:
                    self.can_swipe = True
                else:
                    # If scrollUp, scrollDown or ListWidget does not exist,
                    # it means the current panel is not scrollable nor swipable.
                    pass

    # NonAndroidTouchUPS
    def press_coordinates(self, coordinates, time_sec=0):
        x = coordinates[0]
        y = coordinates[1]
        # Builds after 2.8" Swipe Integartion, it has been observed
        # that delay is also required between presses.
        self.enforce_delay_between_webservice_calls()
        if time_sec > 0:
            touch(x, y)
            time.sleep(time_sec)
            release(x, y)
        else:
            touch_and_release(x, y)

    # NonAndroidTouchUPS
    def get_node_by_attribute(self, attribute_name, attribute_value, expected_count=1):
        # primarily used for scrollers
        # uses self.root, not self.areanode
        whereclause = "{}='{}'".format(attribute_name, attribute_value)
        xpath_condition = convert_whereclause_into_xpath_condition(whereclause)
        node_xpath = ".//object{}".format(xpath_condition)
        scrollnode = self.find_node(self.root, node_xpath, expected_count)
        return scrollnode

    # NonAndroidTouchUPS
    def get_node_coordinates(self, node):
        # gets the center point coordinates
        coordinates = None
        if node is not None:
            x = int(self.get_node_attribute_value(node, "x"))
            y = int(self.get_node_attribute_value(node, "y"))
            width = int(self.get_node_attribute_value(node, "width"))
            height = int(self.get_node_attribute_value(node, "height"))
            mid_x = int(x + width/2)
            mid_y = int(y + height/2)
            coordinates = (mid_x, mid_y)
            #print "%sRMME x: <%s>, y: <%s>, width: <%s>, height: <%s>, \n%s" % ("\033[1;33m", x, y, width, height, "\033[0m")
            #print "%sRMME coordinates: <%s>\n%s" % ("\033[1;33m", coordinates, "\033[0m")
        return coordinates

    # NonAndroidTouchUPS
    def set_expected_count(self):
        self.expected_count = 1

        if self.action == "verify_not_found":
            self.expected_count = 0

    # NonAndroidTouchUPS
    def set_widgetnode_xpath(self):
        self.textnode_xpath_condition = None
        self.widgetnode_xpath_condition = None

        if self.textnode_whereclause is None:
            self.textnode_xpath_condition = convert_whereclause_into_xpath_condition(self.widgetnode_whereclause)
        else:
            self.textnode_xpath_condition = convert_whereclause_into_xpath_condition(self.textnode_whereclause, "text")
        if self.widgetnode_whereclause is not None:
            self.widgetnode_xpath_condition = convert_whereclause_into_xpath_condition(self.widgetnode_whereclause)

    # NonAndroidTouchUPS
    def get_node_attribute_value(self, node, attribute_name):
        return node.xpath(".//{}/text()".format(attribute_name))[0]

    # NonAndroidTouchUPS
    def find_widget(self):
        self.set_areanode()
        self.set_scroll_or_swipe()
        self.set_expected_count()
        self.set_widgetnode_xpath()

        widgetnode = None
        is_boundary_reached = False
        iteration_count = 0
        iteration_max = 100
        scroll_direction = "forward"
        reverse_done = False
        while widgetnode is None:
            #print "%sRMME MAIN LOOP: Scroll Next Pane Traversal --------------------\n%s" % ("\033[1;33m", "\033[0m")
            widgetnode = self.find_widgetnode()
            if widgetnode is None:
                if self.has_scrollnodes or self.can_swipe:
                    #print "%sRMME is_boundary_reached: <%s>\n%s" % ("\033[1;33m", is_boundary_reached, "\033[0m")
                    if not is_boundary_reached:
                        if self.has_scrollnodes:
                            is_boundary_reached = self.scroll_next_pane(scroll_direction)
                        else:
                            # at this point the target widgetnode was not found and
                            # scroll button does not exist. next step is to determine
                            # if user has explicitly set area phrase. if not, it is
                            # safe to set it to ListWidget and swipe. if on the next
                            # swipe the target widgetnode is still not found, UPS
                            # already has set the area to ListWidget and will proceed
                            # to swipe again.
                            if not self.areanode_whereclause:
                                self.set_areanode_to_listwidget()
                            is_boundary_reached = self.full_swipe_to_next_pane(scroll_direction)
                    else:
                        if not reverse_done:
                            # we have reached the bottom boundary
                            scroll_direction = "backward"
                            #print "%sRMME reversing scroll direction to backwards\n%s" % ("\033[1;33m", "\033[0m")
                            if self.has_scrollnodes:
                                is_boundary_reached = self.scroll_next_pane(scroll_direction)
                            else:
                                # at this point the target widgetnode was not found,
                                # scroll button does not exist and UPS is currently
                                # reversing its navigation. next step is to determine
                                # if user has explicitly set area phrase. if not,
                                # it is safe to set it to ListWidget and swipe. if
                                # on the next swipe the target widgetnode is still not
                                # found, UPS already has set the area to ListWidget
                                # and will proceed to swipe again.
                                if not self.areanode_whereclause:
                                    self.set_areanode_to_listwidget()
                                is_boundary_reached = self.full_swipe_to_next_pane(scroll_direction)
                            reverse_done = True
                        else:
                            # we have reached the top boundary
                            break
                    iteration_count += 1
                    if iteration_count == iteration_max:
                        # happens when scrollers go left/right (not up/down)
                        # and just rolls over (won't go disabled at boundary).
                        # the widget you intend to find does not need scrolling
                        # but your in-area phrase or widget phrase is incorrect
                        # forcing it to unintentionally use the scroll for
                        # scrolling to next pane instead of for changing value.
                        # yep you guessed it right, the scrollUp and scrollDown
                        # here are not really used to scroll to next pane but
                        # for setting a value like the scan Darkness setting.
                        msg = "\nIteration limit <{}> reached. Check your in-area and find-widget phrases.\n" \
                              .format(iteration_max)
                        raise ValueError(msg)
                else:
                    # if can't scroll nor swipe, nowhere else to look!
                    break

        if widgetnode is None and self.expected_count == 1 and \
           not self.action.startswith("wait_until_found") and \
           not self.action.startswith("wait_until_not_found"):
            msg = "\nMatching widgets count <0> is not equal to expected count <{}>.\n" \
                  .format(self.expected_count)
            raise ValueError(msg)

        self.widgetnode = widgetnode
        # NOTE: return value is only used by find_widget_with_wait() to support
        # wait_until_found and wait_until_not_found, and is not used in this class.
        return widgetnode

    # NonAndroidTouchUPS
    def scroll_next_pane(self, scroll_direction):
        is_boundary_reached = False
        scroll_name = None
        scrollnode_coordinates = None
        if scroll_direction == "forward":
            scroll_name = "scrollDown"
            scrollnode_coordinates = self.scrolldownnode_coordinates
        else:
            scroll_name = "scrollUp"
            scrollnode_coordinates = self.scrollupnode_coordinates

        scrollnode = self.get_node_by_attribute("name", scroll_name)
        enable_value = self.get_node_attribute_value(scrollnode, "enabled")
        #print "%sRMME scroll_name: <%s>\n%s" % ("\033[1;33m", scroll_name, "\033[0m")
        #print "%sRMME enable_value: <%s>\n%s" % ("\033[1;33m", enable_value, "\033[0m")
        if enable_value == "true":
            self.press_coordinates(scrollnode_coordinates)
            self.set_areanode(check_done=True)
        else:
            is_boundary_reached = True
        return is_boundary_reached

    # NonAndroidTouchUPS
    def find_node(self, areanode, node_xpath, expected_count=1):
        node = None
        nodes = areanode.xpath(node_xpath)
        nodes_count = len(nodes)
        #print "%sRMME nodes_count: <%s>\n%s" % ("\033[1;33m", nodes_count, "\033[0m")

        if expected_count is not None and \
           nodes_count != expected_count:
            msg = "\nMatching widgets count <{}> is not equal to expected count <{}>.\nxpath = <{}>\n" \
                  .format(nodes_count, expected_count, node_xpath)
            raise ValueError(msg)
        if nodes_count == 1:
            node = nodes[0]
        return node

    # NonAndroidTouchUPS
    def find_widgetnode(self):
        widgetnode = None
        textnode_xpath = ".//descendant-or-self::object{}".format(self.textnode_xpath_condition)
        #print "%sRMME textnode_xpath: <%s>\n%s" % ("\033[1;33m", textnode_xpath, "\033[0m")
        textnodes = self.areanode.xpath(textnode_xpath)
        textnodes_count = len(textnodes)
        #print "%sRMME textnodes_count: <%s>\n%s" % ("\033[1;33m", textnodes_count, "\033[0m")

        if textnodes_count > 1:
            if self.expected_count == 0 and not self.widgetnode_xpath_condition:
                msg = "\nExpecting no match but <{}> matching text nodes are found.\n".format(textnodes_count)
                raise ValueError(msg)
            else:
                msg = "\nMore than 1 matching text nodes found. Count = <{}>.\n".format(textnodes_count)
                raise ValueError(msg)
        elif textnodes_count == 1:
            textnode = textnodes[0]
            #print "%sRMME textnode.attrib: <%s>\n%s" % ("\033[1;33m", textnode.attrib, "\033[0m")
            if not self.widgetnode_xpath_condition:
                return textnode

            # find widget node by looking into text node's ancestry
            # starting with text node's parent all the way up to the areanode
            hierarchy_xpath = "./"
            is_areanode_reached = False
            while widgetnode is None:
                #print "%sRMME INNER LOOP: Text Node Ancestry Traversal ----------\n%s" % ("\033[1;33m", "\033[0m")
                #print "%sRMME hierarchy_xpath: <%s>\n%s" % ("\033[1;33m", hierarchy_xpath, "\033[0m")
                #print "%sRMME is_areanode_reached: <%s>\n%s" % ("\033[1;33m", is_areanode_reached, "\033[0m")
                widgetnode = self.find_widgetnode_along_textnode_ancestry(textnode, hierarchy_xpath)
                if widgetnode is not None:
                    break
                if is_areanode_reached:
                    break
                if hierarchy_xpath == "./":
                    hierarchy_xpath = "../" # first ancestor is its parent
                else:
                    hierarchy_xpath += "../" # grandparent and upwards
                # remove the trailing '/' character
                is_areanode_reached = self.is_areanode_reached_fn(textnode, hierarchy_xpath[:-1])

        return widgetnode

    # NonAndroidTouchUPS
    def find_widgetnode_along_textnode_ancestry(self, textnode, hierarchy_xpath):
        widgetnode = None
        widgetnode_xpath = "{}descendant-or-self::object{}".format(hierarchy_xpath, self.widgetnode_xpath_condition)
        #print "%sRMME widgetnode_xpath: <%s>\n%s" % ("\033[1;33m", widgetnode_xpath, "\033[0m")
        widgetnodes = textnode.xpath(widgetnode_xpath)
        widgetnodes_count = len(widgetnodes)
        #print "%sRMME widgetnodes_count: <%s>\n%s" % ("\033[1;33m", widgetnodes_count, "\033[0m")
        if widgetnodes_count > 1:
            if self.expected_count == 0:
                msg = "\nExpecting no match but <{}> matching widgets are found.\n".format(widgetnodes_count)
                raise ValueError(msg)
            else:
                msg = "\nMore than 1 matching widget nodes found. Count = <{}>.\n".format(widgetnodes_count)
                raise ValueError(msg)
        if widgetnodes_count == 1:
            widgetnode = widgetnodes[0]
        return widgetnode

    # NonAndroidTouchUPS
    def is_areanode_reached_fn(self, textnode, hierarchy_xpath):
        ancestornode = None
        is_areanode_reached = False
        #print "%sRMME hierarchy_xpath: <%s>\n%s" % ("\033[1;33m", hierarchy_xpath, "\033[0m")
        ancestornodes = textnode.xpath(hierarchy_xpath)
        ancestornodes_count = len(ancestornodes)
        #print "%sRMME ancestornodes_count: <%s>\n%s" % ("\033[1;33m", ancestornodes_count, "\033[0m")
        if ancestornodes_count == 1:
            ancestornode = ancestornodes[0]
            ancestornode_attrib = self.get_node_attrib(ancestornode)
            is_areanode_reached = compare_dictionaries(self.areanode_attrib, ancestornode_attrib)
        return is_areanode_reached

    # NonAndroidTouchUPS
    def get_node_attrib(self, node):
        node_attrib = {}
        nodes = node.xpath("./*")
        for node in nodes:
            node_attrib[node.tag] = node.text
        #print "%sRMME node_attrib: <%s>\n%s" % ("\033[1;33m", node_attrib, "\033[0m")
        return node_attrib

    # NonAndroidTouchUPS
    def get_widget_attribute_value(self, attribute_name):
        self.find_widget()
        attribute_xpath = "./{}/text()".format(attribute_name)
        curr_attribute_value = None
        nodes = self.widgetnode.xpath(attribute_xpath)
        nodes_count = len(nodes)
        if nodes_count == 0:
            msg = "\nAttribute name <{}> does not exist.\n".format(attribute_name)
            raise ValueError(msg)
        curr_attribute_value = nodes[0]
        return curr_attribute_value

    # NonAndroidTouchUPS
    def do_action(self):
        widgetnode_coordinates = self.get_node_coordinates(self.widgetnode)

        if self.action.startswith("press"):
            self.press_action(widgetnode_coordinates)
        elif self.action == "verify_found":
            pass
        elif self.action == "verify_not_found":
            if self.widgetnode is not None:
                msg = "\nExpecting no match but matching widgetnode is found.\n"
                raise ValueError(msg)
        # support feature file reuse from other panels using v/h-select
        elif self.action.startswith('select'):
            self.select_action()
        elif self.action.startswith("verify"):
            pattern = "verify (.*)='(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                attribute_name = match_object.group(1)
                attribute_value = match_object.group(2)
                attribute_value = unescape_quotes(attribute_value)
                attribute_value = unescape_html(attribute_value)
                curr_attribute_value = self.get_widget_attribute_value(attribute_name)
                if curr_attribute_value != attribute_value:
                    msg = "\nAttribute name <{}> current value <{}> is not equal to expected value <{}>.\n" \
                          .format(attribute_name, curr_attribute_value, attribute_value)
                    raise ValueError(msg)
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action.startswith("type"):
            pattern = "type '(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                text = match_object.group(1)
                text = unescape_quotes(text)
                type_text(text)
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        elif self.action == "clear":
            press_and_release("KEY_Backspace")
            # Pressing backspace once will erase the entire contents.
            # Why? because the old text is highlighted by default.
            # This is for an input field where you plan to type a value.
            # TODO: Add per character deletion support only if needed.
            # For now this is not needed since you don't type to edit and then
            # delete some characters. The case is always: you enter an input
            # field, delete all its text and then type the desired string.
        elif self.action.startswith("wait_until_found") or self.action.startswith("wait_until_not_found"):
            # already processed in the calling fn
            pass
        elif self.action.startswith("return"):
            pattern = "return '(.*)'"
            match_object = re.match(pattern, self.action)
            if match_object:
                attribute_name = match_object.group(1)
                set_global_return(self.get_widget_attribute_value(attribute_name))
            else:
                msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(self.action, pattern)
                raise ValueError(msg)
        else:
            msg = "\nAction <{}> is not valid.\n".format(self.action)
            raise ValueError(msg)

    # NonAndroidTouchUPS
    def do_swipe_action(self, areanode_whereclause, action):
        #print "%sRMME areanode_whereclause: <%s>\n%s" % ("\033[1;33m", areanode_whereclause, "\033[0m")
        #print "%sRMME action: <%s>\n%s" % ("\033[1;33m", action, "\033[0m")
        self.areanode_whereclause = areanode_whereclause
        self.action = action

        # parse action and its specifiers
        direction, count, until_edge = get_swipe_action_specifiers(self.action)

        if self.areanode_whereclause:
            self.initialize()
            self.set_areanode()
            self.set_scroll_or_swipe()
            is_area_boundary_reached = False

            if self.has_scrollnodes:
                msg = "\nCurrent screen have buttons. "\
                      "Thus, swipe action cannot be used.\n"
                raise ValueError(msg)

            if self.can_swipe and count > 0:
                for count_n in range(count):
                    #print "%sRMME count_n: <%s>\n%s" % ("\033[1;33m", count_n, "\033[0m")
                    is_area_boundary_reached = self.full_swipe_to_next_pane(direction)
                    if is_area_boundary_reached:
                        #print "%sRMME is_area_boundary_reached: <%s>\n%s" % ("\033[1;33m", is_area_boundary_reached, "\033[0m")
                        break
            elif self.can_swipe and until_edge:
                while not is_area_boundary_reached:
                    is_area_boundary_reached = self.full_swipe_to_next_pane(direction)
            else:
                msg = "\nCurrent screen cannot be swiped/scrolled.\n"
                raise ValueError(msg)

        else:
            msg = "\nIn-area phrase must be used with swipe action.\n"
            raise ValueError(msg)

    # NonAndroidTouchUPS
    def press_action(self, widgetnode_coordinates):
        self.action = self.action[5:] # 6th up to last character
        time_sec = 0 # press time for long press
        attribute_name = 'none'
        attribute_value = 'none'

        if self.action:
            specifier_default = "0"
            specifier_regex = ":time_sec=(\d+)"
            self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
            time_sec = int(specifier_value) # seconds

            # parse remaining press specifier
            if self.action:
                # conditional press (only once) to set to a desired value
                specifier_default = "none"
                specifier_regex = ":set (.*)='(.*)'"
                self.action, specifier_value1, specifier_value2 = get_specifier_attribute_and_value(self.action, specifier_default, specifier_regex)
                if specifier_value1 != specifier_default:
                    attribute_name = specifier_value1
                    attribute_value = specifier_value2
                    attribute_value = unescape_quotes(attribute_value)

                if self.action:
                    msg = "\nPlease remove action's invalid excess string <{}>.\n".format(self.action)
                    raise ValueError(msg)

                curr_attribute_value = self.get_widget_attribute_value(attribute_name)
                if curr_attribute_value != attribute_value:
                    # single press - only works for binary values (e.g. Off/On).
                    # for multiple values - loop :option_count=n times until
                    # desired value is set but no use case is found. so add
                    # support only when the need arises.
                    # Also, ":time_sec=(\d+)" specifier is ignored if present.
                    self.press_coordinates(widgetnode_coordinates)
                    self.set_areanode(check_done=True)
                    # now let's check if the value changed
                    curr_attribute_value = self.get_widget_attribute_value(attribute_name)
                    if curr_attribute_value != attribute_value:
                        msg = "\nAttribute name <{}> still not set to value <{}> " \
                            "after widget was pressed once.\n".format(attribute_name, attribute_value)
                        raise ValueError(msg)
            else:
                # For simplicity and ease to use, long press specifier
                # ":time_sec=(\d+)" is ONLY applied to unconditional presses.
                # Thus, all other presses have time_sec equal to zero (default).
                self.press_coordinates(widgetnode_coordinates, time_sec=time_sec)
        else:
            # default press with no specifiers
            # unconditional press (w/out time_sec)
            self.press_coordinates(widgetnode_coordinates)

    # NonAndroidTouchUPS
    def select_action(self):
        self.action = self.action[6:] # 7th up to last character
        option_count = -1
        data_type = 'str'
        menu_entry = True
        forward_key = 'scrollDown'
        backward_key = 'scrollUp'
        attribute_name = 'none'
        attribute_value = 'none'

        if self.action:
            specifier_default = "-1"
            specifier_regex = ":option_count=(\d+)"
            self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
            option_count = int(specifier_value)

            specifier_default = "str"
            specifier_regex = ":data_type=(int)"
            self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
            data_type = specifier_value

            specifier_default = "scrollDown"
            specifier_regex = ":forward_key=(\w+)"
            self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
            forward_key = specifier_value

            specifier_default = "scrollUp"
            specifier_regex = ":backward_key=(\w+)"
            self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
            backward_key = specifier_value

            specifier_default = "true"
            specifier_regex = ":menu_entry=(false)"
            self.action, specifier_value = get_specifier_value(self.action, specifier_default, specifier_regex)
            if specifier_value != specifier_default:
                menu_entry = False

            specifier_default = "none"
            specifier_regex = ":set (.*)='(.*)'"
            self.action, specifier_value1, specifier_value2 = get_specifier_attribute_and_value(self.action, specifier_default, specifier_regex)
            if specifier_value1 != specifier_default:
                if specifier_value1 == attribute_name and specifier_value2 == attribute_value:
                    msg = "\nPlease remove action specifier <:set selected='true'> since that is the default behavior.\n"
                    raise ValueError(msg)
                else:
                    attribute_name = specifier_value1
                    attribute_value = specifier_value2
                    attribute_value = unescape_quotes(attribute_value)

            if self.action:
                msg = "\nPlease remove action's invalid excess string <{}>.\n".format(self.action)
                raise ValueError(msg)

        if option_count != -1:
                if data_type == 'int':
                    msg = "\nAction specifiers <option_count> and <data_type> can't both be present.\n"
                    raise ValueError(msg)
                else:
                    self.select_from_unitemized_list(option_count, menu_entry, forward_key, backward_key, attribute_name, attribute_value)
        elif data_type == 'int':
            pattern = "[+-]?\d+"
            match_object = re.match(pattern, attribute_value)
            if match_object:
                attribute_value = int(attribute_value)
                self.select_from_integer_list(menu_entry, forward_key, backward_key, attribute_name, attribute_value)
            else:
                msg = "\nPlease add an action specifier <:set attrib='value'> where value is an integer.\n"
                raise ValueError(msg)
        else:
            # we found no use for an itemized list since there is none. list
            # is broken up and needs scrolling. scrolling is automatic when
            # scrollers are present. so you simply use "press", not "select"
            # self.select_from_itemized_list()
            msg = "\nMust use action specifier <:data_type=int> or <:option_count=n>.\n"
            raise ValueError(msg)

    # NonAndroidTouchUPS
    def select_from_integer_list(self, menu_entry, forward_key, backward_key, attribute_name, attribute_value):
        # use forward/backward keys to navigate to the desired integer value
        # here there is really no itemized integer list. we just know that the
        # integer value increments on forward key press and decrements the
        # other way. the integer values don't even need to be continuous and
        # may skip some values. an error is raised if a key press does not
        # result to a value change
        forward_key_press_count = 0
        backward_key_press_count = 0
        forward_key_node = self.get_node_by_attribute("name", forward_key)
        backward_key_node = self.get_node_by_attribute("name", backward_key)
        forward_key_coordinates = self.get_node_coordinates(forward_key_node)
        backward_key_coordinates = self.get_node_coordinates(backward_key_node)
        key_name = None
        key_coordinates = None
        increment_needed = True
        prev_attribute_value = None
        is_desired_attribute_value_set = False

        i = 1
        while (True):
            curr_attribute_value = self.get_widget_attribute_value(attribute_name)
            pattern = "[+-]?\d+"
            match_object = re.match(pattern, curr_attribute_value)
            if match_object:
                curr_attribute_value = int(curr_attribute_value)
            else:
                msg = "\nAttribute name <{}> current value <{}> does not follow the regex pattern <{}>.\n" \
                      .format(attribute_name, curr_attribute_value, pattern)
                raise ValueError(msg)
            #print "%sRMME Attribute name <%s> current value is <%s>\n%s" % ("\033[1;33m", attribute_name, curr_attribute_value, "\033[0m")
            if curr_attribute_value == attribute_value:
                is_desired_attribute_value_set = True
                break
            elif curr_attribute_value > attribute_value:
                increment_needed = False
            if i > 1 and prev_attribute_value == curr_attribute_value:
                msg = "\nKey <{}> did not change the attribute value on its last press.\n".format(key_name)
                raise ValueError(msg)

            if increment_needed:
                key_name = forward_key
                key_coordinates = forward_key_coordinates
                forward_key_press_count += 1
            else:
                key_name = backward_key
                key_coordinates = backward_key_coordinates
                backward_key_press_count += 1
            self.press_coordinates(key_coordinates)
            #print "%sRMME Key <%s> pressed on iteration <%s>.\n%s" % ("\033[1;33m", key_name, i, "\033[0m")
            self.set_areanode(check_done=True)
            prev_attribute_value = curr_attribute_value
            i += 1

        if is_desired_attribute_value_set:
            if menu_entry:
                press_and_release("KEY_Enter")
        else:
            msg = "\nAttribute name <{}> still not set to value <{}> after\n" \
                  "forward key <{}> was pressed <{}> times and\n" \
                  "backward key <{}> was pressed <{}> times.\n" \
                  .format(attribute_name, attribute_value, \
                          forward_key, forward_key_press_count, \
                          backward_key, backward_key_press_count)
            raise ValueError(msg)

    # NonAndroidTouchUPS
    def select_from_unitemized_list(self, option_count, menu_entry, forward_key, backward_key, attribute_name, attribute_value):
        # use forward/backward keys to navigate to the desired value
        # here there is really no list at all but the total number of navigable
        # options is known. we use that total number (n) to navigate n-1 times
        # forward then n-1 times backward until the desired value is set
        # a sample usage is that of selecting Yes/No button when there are
        # 2 options (n=2). Yes and No buttons are separate widgets (not
        # together in a list). but you can press (n-1) times the forward key
        # then (n-1) times the backward key until desired button is selected
        is_desired_attribute_value_set = False
        forward_key_node = self.get_node_by_attribute("name", forward_key)
        backward_key_node = self.get_node_by_attribute("name", backward_key)
        forward_key_coordinates = self.get_node_coordinates(forward_key_node)
        backward_key_coordinates = self.get_node_coordinates(backward_key_node)
        #key_name = forward_key # commented since used only in debug spit below
        key_coordinates = forward_key_coordinates
        one_direction_keypress_count = option_count - 1
        # -1 above bec current selection does not need key movement
        both_direction_keypress_count = one_direction_keypress_count * 2

        i = 1
        while (i <= (both_direction_keypress_count + 1)):
            # +1 so we can evaluate the result of last iteration's key press
            curr_attribute_value = self.get_widget_attribute_value(attribute_name)
            #print "%sRMME Attribute name <%s> current value is <%s>.\n%s" % ("\033[1;33m", attribute_name, curr_attribute_value, "\033[0m")
            if curr_attribute_value == attribute_value:
                is_desired_attribute_value_set = True
                break
            if i <= both_direction_keypress_count:
                self.press_coordinates(key_coordinates)
                ##print "%sRMME Key <%s> pressed on iteration <%s>.\n%s" % ("\033[1;33m", key_name, i, "\033[0m")
                self.set_areanode(check_done=True)
                if i == one_direction_keypress_count:
                    # at halfway, we reverse direction
                    #print "%sRMME reverse direction\n%s" % ("\033[1;33m", "\033[0m")
                    #key_name = backward_key
                    key_coordinates = backward_key_coordinates
            i += 1

        if is_desired_attribute_value_set:
            if menu_entry:
                press_and_release("KEY_Enter") # should work, but currently wont
                #keys tested to check if they work:
                #press_and_release("KEYCODE_ENTER") # also won't work
                #press_and_release("KEY_Cancel") # works: go to prev screen
                #press_and_release("KEY_Return") # works too: go to prev screen
                #press_and_release("KEY_Start") # works: starts the job
                #press_and_release("KEYCODE_F2") # works: pauses the job
        else:
            msg = "\nAttribute name <{}> still not set to value <{}> after both\n" \
                  "forward key <{}> and then backward key <{}>\n" \
                  "were each pressed <{}> times.\n" \
                  .format(attribute_name, attribute_value, \
                          forward_key, backward_key, \
                          one_direction_keypress_count)
            raise ValueError(msg)

    # NonAndroidTouchUPS
    def full_swipe_to_next_pane(self, swipe_direction, swipe_orientation="vertical"):
        is_area_boundary_reached = False

        x0 = int(self.areanode_attrib["x"])
        y0 = int(self.areanode_attrib["y"])
        x1 = x0 + int(self.areanode_attrib["width"])
        y1 = y0 + int(self.areanode_attrib["height"])

        y1 = y1 - 1 # bottom y1 doesn't work, so we use 1 pixel higher
        x1 = x1 - 4 # use 4 pixels to the right; offset values 1, 2, and 3
                    # touches the scrollbar, hence the value 4.
        #print "%sRMME x0: <%s>, y0: <%s>, x1: <%s>, y1: <%s>\n%s" % ("\033[1;33m", x0, y0, x1, y1, "\033[0m")
        if swipe_direction == "forward":
            if swipe_orientation == "vertical":
                self.swipe(x1, x1, y1, y0)
            else:
                pass # not supported yet
        else:
            if swipe_orientation == "vertical":
                self.swipe(x1, x1, y0, y1)
            else:
                pass # not supported yet
        root = download_panel_xml_into_etree_root("new_panel.xml")
        #print "%sRMME self.areanode_xpath: <%s>\n%s" % ("\033[1;33m", self.areanode_xpath, "\033[0m")
        areanodes = root.xpath(self.areanode_xpath)
        self.areanode = areanodes[self.areanode_index]
        is_area_boundary_reached = self.compare_two_files_if_identical("panel.xml", "new_panel.xml", swipe_orientation)
        os.remove('panel.xml')
        os.rename('new_panel.xml', 'panel.xml')
        return is_area_boundary_reached

    # NonAndroidTouchUPS
    def swipe(self, x0, x1, y0, y1):
        # /webservices/automation/request/swipe is not available in 2.8"
        self.enforce_delay_between_webservice_calls()
        touch(x0, y0)
        release(x1, y1)

    # NonAndroidTouchUPS
    def enforce_delay_between_webservice_calls(self):
        global LAST_WEBSERVICE_CALL_TIMESTAMP
        delay_since_last_webservice_call_sec = time.time() - LAST_WEBSERVICE_CALL_TIMESTAMP
        #print "%sRMME LAST_WEBSERVICE_CALL_TIMESTAMP: <%s>\n%s" % ("\033[1;33m", LAST_WEBSERVICE_CALL_TIMESTAMP, "\033[0m")
        #print "%sRMME delay_since_last_webservice_call_sec: <%s>\n%s" % ("\033[1;33m", delay_since_last_webservice_call_sec, "\033[0m")
        if delay_since_last_webservice_call_sec < self.MIN_DELAY_BETWEEN_WEBSERVICE_CALLS_SEC:
            #print "%sRMME self.sleeping: <%s>\n%s" % ("\033[1;33m", self.MIN_DELAY_BETWEEN_WEBSERVICE_CALLS_SEC - delay_since_last_webservice_call_sec, "\033[0m")
            time.sleep(self.MIN_DELAY_BETWEEN_WEBSERVICE_CALLS_SEC - delay_since_last_webservice_call_sec)
        LAST_WEBSERVICE_CALL_TIMESTAMP = time.time()

    # NonAndroidTouchUPS
    def compare_two_files_if_identical(self, file1, file2, swipe_orientation):
        returncode = -1
        if swipe_orientation == "horizontal":
            pass # not supported yet
        else:
            returncode = filecmp.cmp(file1, file2)
        return returncode

    # NonAndroidTouchUPS
    def set_areanode_to_listwidget(self):
        self.areanode_whereclause = "ListWidget"
        self.set_areanode()

##############################################################################
#
# HELPER FUNCTIONS AND CLASSES
#
##############################################################################
def find_widget_with_wait(areanode_whereclause, action, find_widget):
    # find_widget call within this function currently does not support arguments.
    # to support, add find_widget_args=None as find_widget_with_wait argument,
    # and change the line find_widget() below to:
    #   if find_widget_args is not None:
    #       widgetnode = find_widget(**find_widget_args)
    #   else:
    #       widgetnode = find_widget()

    if areanode_whereclause:
        # disallow in-area phrase since we don't want to scroll
        # otherwise it will be quite complex but useless
        msg = "\nWait action can't be used with in-area phrase.\n"
        raise ValueError(msg)

    widgetnode = None
    max_sec = -1
    expected_found_state = True
    expected_found_state_phrase = "wait_until_found"
    if action.startswith("wait_until_not_found"):
        expected_found_state = False
        expected_found_state_phrase = "wait_until_not_found"

    action_length = len(expected_found_state_phrase)
    # action_validity is not action, just a local declaration to check for
    # validity. action's value should remain unchanged.
    # below is (action_length+1)th up to last character
    action_validity = action[action_length:]

    if action_validity:
        specifier_default = "-1"
        specifier_regex = ":max_sec=(\d+)"
        action_validity, specifier_value = get_specifier_value(action_validity, specifier_default, specifier_regex)
        max_sec = int(specifier_value)

        if action_validity:
            msg = "\nPlease remove action's invalid excess string <{}>.\n".format(action)
            raise ValueError(msg)

    if expected_found_state:
        if max_sec != -1:
            msg = "\nAction specifier <:max_sec> is not applicable for action <{}>.\n".format(expected_found_state_phrase)
            raise ValueError(msg)
        # default screen timeout is 60 seconds (max is 300)
        # NPA_MFP_SETTINGS_TIMEOUT
        try:
            timeout_sec = DEVICE_INFO.get_screen_timeout()
        except Exception:
            timeout_sec = 150   # set to half of the maximum to compensate for
                                # find_widget() connection attempt delays
    else:
        if max_sec == -1:
            msg = "\nAction specifier <:max_sec> should be specified for action <{}>.\n".format(expected_found_state_phrase)
            raise ValueError(msg)
        timeout_sec = max_sec

    retry_count = 0
    interval_sec = 5
    retry_max = timeout_sec / interval_sec
    while (True):
        #print "%sRMME widgetnode: <%s>\n%s" % ("\033[1;33m", widgetnode, "\033[0m")
        retry_count += 1
        try:
            widgetnode = find_widget()
        except Exception:
            widgetnode = None
        if (expected_found_state and widgetnode is not None) or \
            (not expected_found_state and widgetnode is None):
            #print "%sRMME break!\n%s" % ("\033[1;33m", "\033[0m")
            break
        if retry_count > retry_max:
            if expected_found_state:
                error_msg = "Did not find the specified widget"
                timeout_msg = ", which is the device screen timeout"
            else:
                error_msg = "The specified widget is still found"
                timeout_msg = ""

            msg = "\n{} after <{}> retries at <{}-sec> interval\n" \
                    "or a total of <{}> seconds{}.\n" \
                    .format(error_msg, retry_max, interval_sec, \
                            timeout_sec, timeout_msg)
            raise ValueError(msg)
        #print "%sRMME retry_count: <%s>\n%s" % ("\033[1;33m", retry_count, "\033[0m")
        time.sleep(interval_sec)

    # NOTE: return value is only used by the AndroidUPS class; other classes do not.
    return widgetnode

def get_swipe_action_specifiers(action_phrase):
    action = action_phrase
    swipe_direction = None
    swipe_count = -1
    swipe_until_edge = False

    pattern = "swipe direction='(forward|backward)'"
    match_object = re.match(pattern, action)
    if match_object:
        swipe_direction = match_object.group(1)
    else:
        msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(action, pattern)
        raise ValueError(msg)
    #print "%sRMME swipe_direction: <%s>\n%s" % ("\033[1;33m", swipe_direction, "\033[0m")

    specifier_default = "-1"
    specifier_regex = ":count=(\d+)"
    action, specifier_value = get_specifier_value(action, specifier_default, specifier_regex)
    swipe_count = int(specifier_value)
    #print "%sRMME swipe_count: <%s>\n%s" % ("\033[1;33m", swipe_count, "\033[0m")

    specifier_default = "false"
    specifier_regex = ":until_edge=(true)"
    action, specifier_value = get_specifier_value(action, specifier_default, specifier_regex)
    if specifier_value != specifier_default:
        # there is only one valid value: 'true'
        swipe_until_edge = True
    #print "%sRMME swipe_until_edge: <%s>\n%s" % ("\033[1;33m", swipe_until_edge, "\033[0m")

    # swipe_count and until_edge are mutually exclusive;
    # and either of the two is required
    if swipe_count != -1 and swipe_until_edge != False:
        msg = "\nSwipe action specifiers :count=n and :until_edge=true "\
                "are mutually exclusive. Hence, both cannot be used "\
                "together.\n"
        raise ValueError(msg)
    if swipe_count == -1 and swipe_until_edge == False:
        msg = "\nEither :count=n or :until_edge=true is required.\n"
        raise ValueError(msg)

    return swipe_direction, swipe_count, swipe_until_edge

def get_areanode(areanodes, areanodes_count, areanode_index, areanode_whereclause, check_done=False):
    areanode = None

    if check_done:
        areanode = areanodes[areanode_index]
    else:
        if areanodes_count == 0:
            msg = "\nNo matching area nodes found.\n"
            raise ValueError(msg)
        elif areanodes_count == 1:
            if areanode_index > -1:
                msg = "\nOnly one matching area node found.\n" \
                      "Please remove the areanode index specifier <:index={}>\n" \
                      .format(areanode_index + 1)
                raise ValueError(msg)
            else:
                areanode_index = 0
                areanode = areanodes[areanode_index]
        else: # areanodes_count > 0
            if areanode_index == -1 or (areanode_index + 1) > areanodes_count:
                msg = "\nMore than 1 matching area nodes found. Count = <{0}>.\n" \
                      "Please specify a correct areanode index specifier i.e., <{1}:index=[1-{0}]>\n" \
                      .format(areanodes_count, areanode_whereclause)
                raise ValueError(msg)
            else:
                areanode = areanodes[areanode_index]
    return areanode, areanode_index

def do_independent_action(action):
    if action.startswith("press key"):
        pattern = "press key (.*)"
        match_object = re.match(pattern, action)
        if match_object:
            key = match_object.group(1)
            press_and_release(key)
        else:
            msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(action, pattern)
            raise ValueError(msg)
    elif action.startswith("delay"):
        pattern = "delay (\d+|\.\d+|\d+\.\d+) seconds"
        match_object = re.match(pattern, action)
        if match_object:
            seconds = float(match_object.group(1))
            time.sleep(seconds)
        else:
            msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(action, pattern)
            raise ValueError(msg)
    elif action.startswith("type"):
        pattern = "type '(.*)'"
        match_object = re.match(pattern, action)
        if match_object:
            text = match_object.group(1)
            if DEVICE_INFO.is_non_android_non_touch():
                textInput = None
                if DEVICE_INFO.is_panel_2line() and not DEVICE_INFO.is_mfp():
                    textInput = TextInputUsingSingleKey(text)
                else:
                    textInput = TextInputUsingNumpad(text)
                textInput = TextInputUsingNumpad(text)
                textInput.type_text()
            else:
                type_text(text)
        else:
            msg = "\nAction <{}> does not follow the regex pattern <{}>.\n".format(action, pattern)
            raise ValueError(msg)

def get_specifier_value(phrase, specifier_default, specifier_regex):
    specifier_value = specifier_default
    if phrase:
        pattern = "(.*)=(.*)"
        match_object = re.match(pattern, specifier_regex)
        if match_object:
            # e.g. specifier_name = ":index"
            # e.g. specifier_name = ":swipe_offsetx"
            specifier_name = match_object.group(1)
            if specifier_name in phrase:
                pattern = "(.*){}(.*)".format(specifier_regex)
                match_object = re.match(pattern, phrase)
                if match_object:
                    phrase = match_object.group(1)
                    specifier_value = match_object.group(2)
                    phrase += match_object.group(3)
                else:
                    msg = "\nSpecifier <{}> does not follow the regex pattern <{}>.\n".format(specifier_name, specifier_regex)
                    raise ValueError(msg)
        else:
            msg = "\nSpecifier regex <{}> does not follow the regex pattern <{}>.\n".format(specifier_regex, pattern)
            raise ValueError(msg)
    return phrase, specifier_value

def get_specifier_attribute_and_value(phrase, specifier_default, specifier_regex):
    specifier_value1 = specifier_default
    specifier_value2 = specifier_default
    if phrase:
        pattern = "(.*) (.*)=(.*)"
        match_object = re.match(pattern, specifier_regex)
        if match_object:
            # e.g. specifier_name = ":set"
            specifier_name = match_object.group(1)
            if specifier_name in phrase:
                pattern = "(.*){}(.*)".format(specifier_regex)
                match_object = re.match(pattern, phrase)
                if match_object:
                    phrase = match_object.group(1)
                    specifier_value1 = match_object.group(2)
                    specifier_value2 = match_object.group(3)
                    phrase += match_object.group(4)
                else:
                    msg = "\nSpecifier <{}> does not follow the regex pattern <{}>.\n".format(specifier_name, specifier_regex)
                    raise ValueError(msg)
        else:
            msg = "\nSpecifier regex <{}> does not follow the regex pattern <{}>.\n".format(specifier_regex, pattern)
            raise ValueError(msg)
    return phrase, specifier_value1, specifier_value2

def convert_whereclause_into_xpath_condition(whereclause, attribute_type=None):
    # Example:
    # whereclause = "attrib1='value1'&&attrib2='value2'"
    # xpath_condition = "[attrib1='value1'][attrib2='value2']"

    xpath_condition = ""
    if '=' not in whereclause:
        if attribute_type is not None:
            condition = "{}='%s'".format(attribute_type)
            condition = condition % whereclause # % has unicode support
            quote_correct_condition = get_quote_correct_condition(condition)
            xpath_condition = "[" + quote_correct_condition + "]"
        else:
            xpath_condition = "[type='" + whereclause + "']"
    else:
        # split the multiple conditions
        conditions = whereclause.split('&&')
        for condition in conditions:
            pattern = "(.*)='(.*)'"
            match_object = re.match(pattern, condition)
            if match_object:
                quote_correct_condition = get_quote_correct_condition(condition)
                xpath_condition += "[" + quote_correct_condition + "]"
            else:
                msg = "\nCondition <{}> does not follow the regex pattern <{}>.\n".format(condition, pattern)
                raise ValueError(msg)

    return unescape_html(xpath_condition)

def compare_dictionaries(dict1, dict2):
    is_same_dict = True
    if len(dict1) != len(dict2):
        is_same_dict = False
    else:
        for key, value in list(dict1.items()):
            if key in dict2:
                if value != dict2[key]:
                    is_same_dict = False
                    break
            else:
                is_same_dict = False
                break
    return is_same_dict

def is_dict1_subset_of_dict2(dict1, dict2, exact_match=True):
    is_subset_dict = True
    if len(dict1) <= len(dict2):
        for key, value in list(dict1.items()):
            if key in dict2:
                if exact_match:
                    if value != dict2[key]: # strict version
                        is_subset_dict = False
                        break
                else:
                    # yes, not exact match but a substring
                    if dict2[key].lower().find(value.lower()) < 0:
                        is_subset_dict = False
                        break
            else:
                is_subset_dict = False
                break
    return is_subset_dict

def get_quote_correct_condition(condition):
    # user must input single quote as "&apos;" and double quote as "&quot;"
    # Example 1:
    # input: attrib1='I said &apos;Hi&apos; to the stranger.'
    # output: attrib1="I said 'Hi' to the stranger."
    # (outermost quotes now double quotes)
    # Example 2:
    # input: attrib1='I said &quot;Hi&quot; to the stranger.'
    # output: attrib1='I said "Hi" to the stranger.'
    # (outermost quotes still single quotes)
    single_quote = "'"
    double_quote = '"'
    esc_single_quote = "&apos;"
    esc_double_quote = "&quot;"
    multiple_quote_type = False

    if esc_single_quote in condition:
        if esc_double_quote in condition:
            multiple_quote_type = True
        else:
            condition = condition.replace(single_quote, double_quote)
            condition = condition.replace(esc_single_quote, single_quote)
    elif esc_double_quote in condition:
        if esc_single_quote in condition:
            multiple_quote_type = True
        else:
            condition = condition.replace(double_quote, single_quote)
            condition = condition.replace(esc_double_quote, double_quote)

    if multiple_quote_type:
        msg = "\nCondition <{}> can't contain both escaped single quote <{}> " \
              "and escaped double quote <{}>.\n" \
              .format(condition, esc_single_quote, esc_double_quote)
        raise ValueError(msg)

    #print "%sRMME condition: <%s>\n%s" % ("\033[1;33m", condition, "\033[0m")
    return condition

def escape_quotes(str):
    single_quote = "'"
    double_quote = '"'
    esc_single_quote = "&apos;"
    esc_double_quote = "&quot;"
    multiple_quote_type = False

    if single_quote in str:
        if double_quote in str:
            multiple_quote_type = True
        else:
            str = str.replace(single_quote, esc_single_quote)
    elif double_quote in str:
        if single_quote in str:
            multiple_quote_type = True
        else:
            str = str.replace(double_quote, esc_double_quote)

    if multiple_quote_type:
        msg = "\nString <{}> can't contain both escaped single quote <{}> " \
              "and escaped double quote <{}>.\n" \
              .format(str, esc_single_quote, esc_double_quote)
        raise ValueError(msg)

    return str

def unescape_quotes(str):
    # this is used in action phrase.
    # multiple quote type is allowed unlike in in-area, on-text,
    # and find-widget phrases where they are used in xpath which
    # we do not yet support both quotes
    single_quote = "'"
    double_quote = '"'
    esc_single_quote = "&apos;"
    esc_double_quote = "&quot;"

    str = str.replace(esc_single_quote, single_quote)
    str = str.replace(esc_double_quote, double_quote)

    return str

def unescape_html(_str):
    # Interpret html-code/s as unicode.
    # https://ascii.cl/htmlcodes.htm
    # https://unicode-table.com/en/

    return html.parser.HTMLParser().unescape(_str)

def convert_str_to_sha1(str):
    hash_object = hashlib.sha1(str)
    hex_digest = hash_object.hexdigest()
    return hex_digest

def register_events(events='viewClicked,viewUpdated,viewChanged'):
    # implement eventing without having to maintain an open connection to the client
    url = "http://{}/webservices/automation/request/listen?ip={}&port={}&events={}".format(IP_ADDRESS, HOST_IP, PORT, events)
    execute_http_request(url)

def unregister_events(events='viewClicked,viewUpdated,viewChanged'):
    # unregister eventing
    url ="http://{}/webservices/automation/request/silence?ip={}&port={}&events={}".format(IP_ADDRESS, HOST_IP, PORT, events)
    execute_http_request(url)

def swipe(x0, x1, y0, y1, t):
    # Emulate a finger swiping across the touchscreen
    # from (x0,y0) to (x1,y1) in t ms
    url = "http://{}/webservices/automation/request/swipe?x0={}&x1={}&y0={}&y1={}&t={}".format(IP_ADDRESS, x0, x1, y0, y1, t)
    execute_http_request(url)

def touch_and_release(x, y, time_sec=0):
    url = "http://{}/webservices/automation/request/touchAndRelease?x={}&y={}".format(IP_ADDRESS, x, y)
    if time_sec > 0:
        swipe(x, x, y, y, time_sec)
    else:
        execute_http_request(url)

def press_and_release(key):
    url = "http://{}/webservices/automation/request/pressAndReleaseKey?key={}".format(IP_ADDRESS, key)
    execute_http_request(url)
    # TODO: call RECENT_EVENT_DATA.clear() here instead of:
    # global RECENT_EVENTS_DICT
    # global RECENT_EVENTS_LIST
    # RECENT_EVENTS_DICT = {}
    # RECENT_EVENTS_LIST = []

    # TODO: change this hard delay to:
    # if DEVICE_INFO.is_panel_2line():
    #     RECENT_EVENTS_DATA.wait_for_event("viewUpdate", "viewUpdated")
    delay()

def touch(x, y):
    url = "http://{}/webservices/automation/request/touch?x={}&y={}".format(IP_ADDRESS, x, y)
    execute_http_request(url)

def release(x, y):
    url = "http://{}/webservices/automation/request/release?x={}&y={}".format(IP_ADDRESS, x, y)
    execute_http_request(url)

def type_text(text):
    text = urllib.parse.quote_plus(text)
    url = "http://{}/webservices/automation/request/enterText?text={}".format(IP_ADDRESS, text)
    execute_http_request(url)

def execute_http_request(url):
    #print "%sRMME url: <%s>\n%s" % ("\033[1;33m", url, "\033[0m")
    handle = urllib.request.urlopen(url)
    handle.close()

def get_tree_root_from_file(filepath):
    root = None
    root_xpath = ""
    if DEVICE_INFO.is_android():
        root_xpath = "./node"
    else:
        root_xpath = "./descendant-or-self::panel"
    #print "%sRMME root_xpath: <%s>\n%s" % ("\033[1;33m", root_xpath, "\033[0m")
    root = etree.parse(filepath).xpath(root_xpath)[0]
    return root

def download_panel_png(filepath):
    url = "http://{}/webservices/automation/data/panel.png".format(IP_ADDRESS)
    urllib.request.urlretrieve (url, filepath)

def download_panel_xml_into_etree_root(filepath):
    root = None
    #if not DEBUG_PANEL_XML: # normal mode
    result = False
    retry_max = 10
    retry_interval_sec = 1
    delay()
    url = "http://{}/webservices/automation/data/panel.xml".format(IP_ADDRESS)
    for i in range(retry_max):
        try:
            urllib.request.urlretrieve (url, filepath)
            root = get_tree_root_from_file(filepath)
            result = True
            break
        except:
            time.sleep(retry_interval_sec)
    if not result:
        msg = "\nDownloaded panel.xml still badly formed " \
              "after <{}> retries in <{}> sec interval.\n" \
              .format(retry_max, retry_interval_sec)
        raise ValueError(msg)
    #else: # debug mode (Offline Debugging)
    #    if os.path.exists(DEBUG_PANEL_XML):
    #        root = get_tree_root_from_file(DEBUG_PANEL_XML)
    #    else:
    #        msg = "\nPanel xml file <{}> not found.\n".format(DEBUG_PANEL_XML)
    #        raise ValueError(msg)
    return root

def popen_command(cmd, preferred_return='output', do_assert=False):
    #print "cmd: <%s>" % (cmd)
    proc = Popen(cmd, stdout=PIPE, shell=True)
    output, err = proc.communicate()
    returncode = proc.returncode
    #print "output: <%s>" % (output)
    #print "err: <%s>" % (err)
    #print "returncode: <%s>\n" % (returncode)
    if do_assert:
        if returncode != 0:
            msg = "Command <%s> failed" % (cmd)
            raise ValueError(msg)
    if preferred_return == 'returncode':
        return returncode
    return output.decode("utf-8") if type(output) is bytes else output

def delay():
    #print "%sRMME DELAY_SEC\n%s" % ("\033[1;36m", "\033[0m")
    time.sleep(DELAY_SEC)

def set_host_ip():
    output = socket.gethostbyname(socket.getfqdn())
    output = output.replace("\n", "") # remove trailing newline
    global HOST_IP
    HOST_IP = output
    #print "%sRMME HOST_IP: <%s>\n%s" % ("\033[1;33m", HOST_IP, "\033[0m")
    return output

def get_regex_substr(regex, str):
    # limited use only
    # returns the first match of the first group of regex
    # yes, multiple regex can be found in a string but we are not using that here
    # group(0) returns the full matching string, not just on the matching regex part
    first_match = ""
    match_object = re.search(regex, str)
    if match_object:
        first_match = match_object.group(1)
    else:
        pass
        #print "%sRMME Regex pattern <%s> not found in string <%s>\n%s" % ("\033[1;33m", regex, str, "\033[0m")
    return first_match

def set_global_return(value):
    # workaround to set return value
    global GLOBAL_RETVAL
    GLOBAL_RETVAL = value

##############################################################################
#
# DEVICE INFO - non-rob/ssh approach to getting device info
#
##############################################################################
class DeviceInfo():
    # TODO: add class logging
    # NOTE: AVOID DEPENDENCIES ON FW VERSION (either from EWS or ROB) TO AVOID
    #       COMPLEXITY AND AVOID THE NEED TO CATCH MULTIPLE CASES; KEEP IT SIMPLE
    def __init__(self, ip, rob=None):
        # Class utility variables
        self._ip = ip
        self._init = False
        self._panel_img_file = "panel_{}.png".format(int(time.time()))

        # Initialization-required Printer Descriptions
        self._panel_size = None
        self._res_x = None
        self._res_y = None
        self._is_panel_touch = None
        self._is_sim = False

    ################################################################################
    # Publicly-usable Functions; Add below as needed ###############################
    # Public init method; should be used after class instantation #################
    def initialize(self):
        if not self._init:
            # NOTE: init only getters for non-changing printer description (i.e. panel size, resolution);
            #       different from class constructor.
            self._get_panel()
            self._init = True
            self._print()

    ################################################################################
    # Get Screen Timeout setting from EWS; returns timeout in seconds (int) ########
    def get_screen_timeout(self):
        data = self._get_response("/webglue/content?c=%2FScreenTimeout", attempts=3)
        return int(data['nodes']['settings'][str(data['nodes']['nodes']['ScreenTimeout']['setting'])]['val'])

    ################################################################################
    # Get FW Version; returns formatted version (str) ##############################
    def get_firmware_version(self):
        data = self._get_response("/webglue/content?c=%2FDeviceFirmwareLevel", attempts=3)
        return str(data['nodes']['nodes']['DeviceFirmwareLevel']['text']['text'])

    ################################################################################
    # Is Printer Color? return boolean #############################################
    def is_color(self):
        data = self._get_response("/webglue/content?c=%2FDeviceType", attempts=3)
        return (str(data['nodes']['nodes']['DeviceType']['text']['text']) == 'Color')

    ################################################################################
    # Is Printer MFP? return boolean ###############################################
    def is_mfp(self):
        data = self._get_response("/webglue/content?c=%2FCopy", attempts=3)
        return (len(data['nodes']['nodes']) != 0)

    def is_sim(self):
        self._require_init()
        return self._is_sim

    ################################################################################
    # Get Panel Size; returns panel size (str) #####################################
    def get_panel_size(self):
        self._require_init()
        return self._panel_size

    ################################################################################
    # Get Panel Resolution; returns X and Y resolution (int) #######################
    def get_panel_resolution(self):
        self._require_init()
        return (self._res_x, self._res_y)

    ################################################################################
    # Is Printer Android? return boolean ###########################################
    def is_android(self):
        self._require_init()
        return (self._panel_size in [ "4.3", "7", "10" ])

    ################################################################################
    # Is Printer Non-Android Touch? return boolean #################################
    def is_non_android_touch(self):
        self._require_init()
        return (self._panel_size in [ "2.8" ])

    ################################################################################
    # Is Printer Non-Android Non-Touch? return boolean #################################
    def is_non_android_non_touch(self):
        self._require_init()
        return (self._panel_size in [ "2.4", "2L"])

    ################################################################################
    # Is Printer Non-Android? return boolean #######################################
    def is_non_android(self):
        self._require_init()
        return (self._panel_size in [ "2.4", "2.8", "2L"])

    ################################################################################
    # Is Panel 2-line? return boolean ##############################################
    def is_panel_2line(self):
        self._require_init()
        return (self._panel_size == "2L")

    ################################################################################
    # Is Panel touch? return boolean ###############################################
    def is_panel_touch(self):
        self._require_init()
        return self._is_panel_touch

    ################################################################################
    # Is Panel non-touch? return boolean ###########################################
    def is_panel_non_touch(self):
        self._require_init()
        return not self._is_panel_touch


    ################################################################################
    # Privately-used Functions; Add below as needed ################################
    def _require_init(self):
        if not self._init:
            msg = "\nDeviceInfo.initialize() should be called to get dependencies!"
            raise ValueError(msg)

    def _get_response(self, url, attempts, headers=None, use_default_headers=True, body=""):
        cnt = 0
        resp = None
        conn = None
        success = False

        if use_default_headers:
            headers = {
                'Accept': 'application/json, text/javascript',
                "Content-type": "application/x-www-form-urlencoded;",
                "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
            }

        while cnt < attempts and success is False:
            try:
                conn = http.client.HTTPConnection(self._ip + ':80')
                conn.request("GET", url, body, headers)
                resp = conn.getresponse()
                success = True
            except socket.error:
                if cnt >= attempts:
                    success = False
                else:
                    pass
                time.sleep(3)
            cnt += 1

        if success is False:
            msg = "\nUnable to get response from {}".format(url)
            raise ValueError(msg)
        else:
            if resp.status != 200:
                msg = "\nReturn status from {} is not 200".format(url)
                raise ValueError(msg)
            else:
                response_data = resp.read()
                try:
                    data = json.loads(response_data.decode("utf-8"))
                except ValueError:
                    data = response_data
                conn.close()
                return data

    def _get_panel(self):
        # Download Panel Image and Get Resolution
        url = "http://{}/webservices/automation/data/panel.png".format(self._ip)
        urllib.request.urlretrieve(url, self._panel_img_file)
        self._res_x, self._res_y = self._get_image_resolution()

        # Delete downloaded image
        os.remove(self._panel_img_file)

        # Resolution : panel type relationship
        if self._res_x == 1024:
            self._panel_size = "10"
            self._is_panel_touch = True
        elif self._res_x == 800:
            self._panel_size = "7"
            self._is_panel_touch = True
        elif self._res_x == 480:
            self._panel_size = "4.3"
            self._is_panel_touch = True
        elif self._res_x == 320:
            # NOTE: Special case for 2.8
            if self._xml_has_object_tag():
                self._panel_size = "2.8"
                self._is_panel_touch = True
            else:
                self._panel_size = "2.4"
                self._is_panel_touch = False
        elif self._res_x == 128:
            self._panel_size = "2L"
            self._is_panel_touch = False
        else:
            msg = "\nUnsupported panel size with resX <{}>.\n".format(self._res_x)
            raise ValueError(msg)

        if OS != 'windows':
            cmd = 'ssh {} -l root -oBatchMode=yes "cat /Build.Info | grep Persona"'.format(self._ip)
            output = popen_command(cmd, do_assert=False)
            if "sim" in output:
                self._is_sim = True

    def _get_image_resolution(self):
        # Source: https://stackoverflow.com
        # /questions/8032642/how-to-obtain-image-size-using-standard-python-class-without-using-external-lib

        # Private Constants
        IMG_HEAD = 24
        PNG_SIGNATURE = 0x0d0a1a0a
        SIZE = 2
        FTYPE = 0

        # ValueError will be raised after open's __exit__ method
        with open(self._panel_img_file, 'rb') as image:
            head = image.read(IMG_HEAD)

            if len(head) != IMG_HEAD:
                msg = "\nDeviceInfoError: Invalid image head length <{}>".format(len(head))
                raise ValueError(msg)

            # GIF
            if image_type(self._panel_img_file) == 'gif':
                width, height = struct.unpack('<HH', head[6:10])
            # PNG
            elif image_type(self._panel_img_file) == 'png':
                signature = struct.unpack('>i', head[4:8])[0]
                if signature != PNG_SIGNATURE:
                    msg = "\nDeviceInfoError: Invalid PNG signature <{}>".format(signature)
                    raise ValueError(msg)
                width, height = struct.unpack('>ii', head[16:24])
            # JPEG
            elif image_type(self._panel_img_file) == 'jpeg':
                try:
                    image.seek(0) # Read 0xff next
                    while not 0xc0 <= FTYPE <= 0xcf:
                        image.seek(SIZE, 1)
                        byte = image.read(1)
                        while ord(byte) == 0xff:
                            byte = image.read(1)
                        FTYPE = ord(byte)
                        SIZE = struct.unpack('>H', image.read(2))[0] - 2
                    # SOFn block
                    image.seek(1, 1)  # Skip `precision' byte.
                    height, width = struct.unpack('>HH', image.read(4))
                except:
                    msg = "\nDeviceInfoError: Error processing JPEG image file"
                    raise ValueError(msg)
            else:
                msg = "\nDeviceInfoError: Unsupported image type <{}>".format(image_type(self._panel_img_file))
                raise ValueError(msg)
            return width, height

    def _xml_has_object_tag(self):
        xml = self._get_response("/webservices/automation/data/panel.xml", attempts=3)
        return (len(etree.fromstring(xml).xpath(".//object")) != 0)

    ################################################################################
    # Development method; test all getters; add below  #############################
    def _print(self):
        pass
        #print "get_screen_timeout: {}".format(self.get_screen_timeout())
        #print "get_firmware_version: {}".format(self.get_firmware_version())
        #print "is_color: {}".format(self.is_color())
        #print "is_mfp: {}".format(self.is_mfp())
        #print "get_panel_size: {}".format(self.get_panel_size())
        #print "get_panel_resolution: {}".format(self.get_panel_resolution())
        #print "is_android: {}".format(self.is_android())
        #print "is_non_android: {}".format(self.is_non_android())
        #print "is_panel_2line: {}".format(self.is_panel_2line())
        #print "is_panel_touch: {}".format(self.is_panel_touch())
        #print "is_panel_non_touch: {}".format(self.is_panel_non_touch())

##############################################################################
#
# RUNNING AS STAND-ALONE PYTHON SCRIPT
#
##############################################################################

# This section is for using this file as a stand-alone python script.
# You should be familiar how to use the universal panel step. The full
# updated documentation is found at README_universal.txt. The input to
# this script is a feature file. Be sure that you have run your feature file
# in the lettuce-runner first before feeding it to this script. This script
# has limited error checking for feature file syntax. I will state the obvious
# just in case it is not clear to you. Since this is a stand-alone script for
# universal panel step, then all steps in your feature file must be
# universal panel steps.
# Format:
#     python universal_panel_step.py $IP <testfile.feature> [<scenario_list>]
# Sample Usage:
#     python universal_panel_step.py $IP mytest.feature
#     python universal_panel_step.py $IP mytest.feature 1
#     python universal_panel_step.py $IP mytest.feature 1,2
#     python universal_panel_step.py $IP mytest.feature 1,2,3
#
# Offline Debugging (developer use only):
# Update 20180515: Offline debugging is disabled until it is restored.
#     Useful for debugging where you don't have access to the device and
#     only the panel.xml file is given and the failing step. Yes you have
#     to put the failing step inside a feature file to use this method.
# Format:
#     python universal_panel_step.py $IP <testfile.feature> <panel.xml>
# Sample Usage:
#     python universal_panel_step.py $IP mytest.feature mypanel.xml

def run_ups_as_stand_alone_script():
    script_name = sys.argv[0]
    num_args = len(sys.argv)
    if num_args > 2:
        global DEVICE_INFO
        global IP_ADDRESS
        ip_address = sys.argv[1]
        IP_ADDRESS = ip_address
        scenario_list = []
        feature_file = sys.argv[2]
        if feature_file == "pause-screen":
            # Tool: Pause the current screen (developer use only)
            # Usage: python universal_panel_step.py $IP pause-screen
            # this is useful for android or non-android panels for pausing
            # your screen for testing, yes any screen even child modal screens.
            DEVICE_INFO = DeviceInfo(ip=ip_address)
            DEVICE_INFO.initialize()
            resX, resY = DEVICE_INFO.get_panel_resolution()
            while (True):
                if DEVICE_INFO.is_panel_touch():
                    # does't work with 2.8". an offset of -1 also doesn't work
                    # since it will click scrollDown. top click won't also.
                    touch_and_release(resX, resY)
                else:
                    # works unless your current screen has
                    # left-right navigable widget
                    press_and_release("KEY_Right")
                time.sleep(10)
        elif num_args > 3:
            str = sys.argv[3]
            # comma-delimited ints with no spaces in between
            scenario_pattern = "^\d+(,\d+)*$"
            scenario_match_object = re.match(scenario_pattern, str)
            # panel.xml filename
            filename_pattern = "(.*)\.xml"
            filename_match_object = re.match(filename_pattern, str)
            if scenario_match_object:
                # normal mode
                scenario_list = str.split(',')
                # convert list of strings to list of int
                scenario_list = list(map(int, scenario_list))
                #print "%sRMME scenario_list: <%s>\n%s" % ("\033[1;33m", scenario_list, "\033[0m")
                DEVICE_INFO = DeviceInfo(ip=ip_address)
                DEVICE_INFO.initialize()
            elif filename_match_object:
                # debug mode (Offline Debugging)
                # use the provided panel.xml file
                pass
                msg = "\nOffline debugging disabled until it is restored.\n"
                raise ValueError(msg)
            else:
                msg = "\nScenario list <{}> does not follow the regex pattern <{}>.\n" \
                      .format(str, scenario_pattern)
                raise ValueError(msg)
        #set_host_ip()
        #start_event_listener()
        execute_feature_file(feature_file, scenario_list)
        #stop_event_listener()
    else:
        print(("Usage: python {0} <ip_address> <testfile.feature> [<scenario_list>]\n"
              "Example: python {0} 10.194.5.10 testfile.feature 1,2,3".format(script_name)))

def execute_feature_file(filename, scenario_list):
    with open(filename) as file:
        feature_line_comment = False
        current_scenario = 0
        for line in file:
            line = line.lstrip()
            if not line or line[0] == '#':
                continue
            if line.startswith("Feature:"):
                feature_line_comment = True
                continue
            elif line.startswith("Scenario:"):
                feature_line_comment = False
                current_scenario += 1
                continue
            elif feature_line_comment:
                continue
            if not scenario_list or current_scenario in scenario_list:
                execute_step_regex(line)

def execute_step_regex(step, min_interval=0.25):
    # this line should be left uncommented for end-user to see the currently
    # executed step
    print(("%s%s%s" % ("\033[1;36m", step, "\033[0m")))

    # set LAST_EXEC_STEP_REGEX to global to update its value after
    global LAST_EXEC_STEP_REGEX

    # apply delay when necessary based on min_interval
    interval = time.time() - LAST_EXEC_STEP_REGEX
    if interval < min_interval:
        # calculate remaining delay needed
        delay = min_interval - interval
        time.sleep(delay)

    retval = None
    pattern = '(|In area "([^"]*)" )(|On text "([^"]*)" )(|Find widget "([^"]*)" )(Do "([^"]*)")'
    match_object = re.match(pattern, step, re.IGNORECASE)
    if match_object:
        area_phrase = match_object.group(1)
        areanode_whereclause = match_object.group(2)
        text_phrase = match_object.group(3)
        textnode_whereclause = match_object.group(4)
        widget_phrase = match_object.group(5)
        widgetnode_whereclause = match_object.group(6)
        action_phrase = match_object.group(7)
        action = match_object.group(8)
        retval = find_widget_and_do_action(area_phrase, areanode_whereclause, \
                                  text_phrase, textnode_whereclause, \
                                  widget_phrase, widgetnode_whereclause, \
                                  action_phrase, action)
        # this line should be left uncommented for end-user to see the
        # successfully completed step
        print(("%s%s%s" % ("\033[1;32m", step, "\033[0m")))
    else:
        msg = "\nStep <{}> does not follow the regex pattern <{}>.\n" \
              .format(step, pattern)
        raise ValueError(msg)

    # store timestamp
    LAST_EXEC_STEP_REGEX = time.time()
    return retval

if __name__ == '__main__':
    run_ups_as_stand_alone_script()
